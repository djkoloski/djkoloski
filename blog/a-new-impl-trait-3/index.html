<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Software Engineer, Game Designer, Web Developer">
    <meta name="author" content="David Koloski">

    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="theme-color" content="#ffffff">

    <!-- fonts and styles -->
    <link href="https://fonts.googleapis.com/css?family=Rubik:400,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata:500,800" rel="stylesheet">
    <link href="https://david.kolo.ski/style.css" rel="stylesheet">

    <!-- scripts -->
    <script src="/elasticlunr.min.js" async></script>
    <script src="/search_index.en.js" async></script>
    <script src="/search.js" async></script>

    <title>
        
            A new impl Trait 3&#x2F;4
        
    </title>
</head>
<body>
    <div class="section header">
        <div class="logo">
            <a href="/" class="logo-image" width="100"></a>
        </div>
        <div class="links">
            
            
                <a href="https://david.kolo.ski/about/">About</a>
            
                <a href="https://david.kolo.ski/resume/">Resume</a>
            
            
                
                <a href="https://david.kolo.ski/blog/">Blog</a>
            
        </div>
        <div class="search">
            <input id="search-checkbox" type="checkbox" autocomplete="off">
            <input id="search-input" type="text" placeholder="Search">
            <label id="search-show" for="search-checkbox"></label>
        </div>
    </div>
    
<div class="section title">
    A new impl Trait 3/4
    <div class="subtitle">
        The current state of <code>impl Trait</code>
    </div>
    <div class="subtitle">
        May 12, 2022 &ndash; 9 min read
    </div>
</div>
<div class="section taxonomies">
    
    <div class="tags">
        
            <a href="https://david.kolo.ski/tags/rust/">Rust</a>
        
    </div>
    
    <div class="categories">
        
            <a href="https://david.kolo.ski/categories/rust/">Rust</a>
        
    </div>
    
</div>
<div class="section content">
    <p>If you're not interested in reading about the prior work done on <code>impl Trait</code>, feel free to skip ahead to <a href="https://david.kolo.ski/blog/a-new-impl-trait-4/">the fourth and final post</a>.</p>
<h2 id="prior-work">Prior work</h2>
<p>The concepts behind <code>impl Trait</code> have been around for a surprisingly long time. I've done my best to collect relevant RFCs, successful and failed, review them and compare them to my proposal. There are five RFCs that are directly relevant to <code>impl Trait</code> and type abstraction. Let's go in chronological order.</p>
<h2 id="the-original-impl-trait">The original <code>impl Trait</code></h2>
<p>The <a href="https://github.com/rust-lang/rfcs/pull/105/files">first <code>impl Trait</code> RFC</a> from <a href="https://github.com/aturon">@aturon</a> was not accepted, but a proposed <a href="https://rust-lang.github.io/rfcs/1522-conservative-impl-trait.html">more conservative version</a> of it was accepted.</p>
<p>In many ways, this RFC has the same goals as my recommendation. Specifically, it addresses the following by name:</p>
<ul>
<li>Returning unboxed closures - this now also applies to unboxed <code>Futures</code> generated by <code>async</code> blocks</li>
<li>Preventing leaky APIs - this is related to trait leakage when returning unabstracted types, one of the problems that we're trying to solve</li>
<li>Simplifying complex types - the given example is heavily-composed iterator types</li>
<li>Documentation - namely making it easier to understand complex return types</li>
</ul>
<p>It even proposed allowing <code>impl Trait</code> in any type position, which <code>as impl Trait</code> also aims to allow. Thare are places in the thread where <code>as impl Trait</code> is even used, albeit in the context of a value. So why was the more conservative version accepted instead of the original?</p>
<h3 id="impl-trait-anywhere"><code>impl Trait</code> anywhere</h3>
<p>The original proposal didn't have a concrete use-case for <code>impl Trait</code> outside of function signatures. With a more current need for TAIT, I would say that we now have a motivating use case for it.</p>
<h3 id="named-return-types">Named return types</h3>
<p>The original proposal suggested syntax like <code>collect_to_set::&lt;T, I&gt;::impl</code> to refer to the <code>impl Trait</code> return type of the function <code>collect_to_set</code>. This raised questions about how to refer to nested return types. <code>as impl Trait</code> does not have this problem, since the correct approach in this case would be to separate the return type into a type alias. It is good to question how named unnameable types interact with distant type aliases though and whether this would be an issue. Nested <code>as impl Trait</code>s can be approached in the same way.</p>
<h3 id="trait-object-confusion">Trait object confusion</h3>
<p>There was a lot of concern that it would be easy to confuse <code>impl Trait</code> (a statically-dispatched abstract type) with <code>Trait</code>. At the time, <code>Trait</code> was the syntax for trait objects. It has since been replaced with <code>dyn Trait</code> and deprecated, so the risk of confusion is lower now than ever. Additionally, I think that <code>Type as impl Trait</code> conveys a much larger difference from <code>dyn Trait</code> than <code>impl Trait</code> does.</p>
<h3 id="impl-trait-is-not-powerful-enough"><code>impl Trait</code> is not powerful enough</h3>
<p><code>impl Trait</code> was proposed as being a very general-purpose equivalent of existential types, which <code>as impl Trait</code> does not. There was some reluctance to having two ways to express the same concept, which isn't as much of a problem with <code>as impl Trait</code>.</p>
<h3 id="coupled-sugarings">Coupled sugarings</h3>
<p><a href="https://github.com/pnkfelix">@pnkfelix</a> actually calls this out explicitly in <a href="https://github.com/rust-lang/rfcs/pull/105#issuecomment-45329909">a comment</a>, how <code>impl Trait</code> has two different uses depending on whether it's used in argument position or return position. There's also discussion about how covariant and contravariant appearances of <code>impl Trait</code> have different desugarings, and even a suggestion that <code>some Trait</code> be introduced to capture that notion. This parallels a lot of what was discussed in the first post.</p>
<h3 id="leaky-auto-traits">Leaky auto traits</h3>
<p>This was a controversial aspect at the time, but it's now well-known that abstractions leak auto traits. This hasn't changed, and the previous discussion is extensive and not worth rehashing.</p>
<h3 id="conclusion">Conclusion</h3>
<p>At the end of it all, @aturon closed the RFC in favor of working towards some alternatives with other interested members.</p>
<p>This first RFC does somewhat of a whirlwind tour of the problems that <code>impl Trait</code> attempts to solve. Existential types made an appearance, conditional trait bounds showed up, and there was speculative syntax galore. It properly sets the stage for:</p>
<h2 id="conservative-impl-trait">Conservative <code>impl Trait</code></h2>
<p><a href="https://rust-lang.github.io/rfcs/2071-impl-trait-existential-types.html">This RFC</a> is essentially just a limited version of the original proposal. It only allows <code>impl Trait</code> in argument and return position on free and inherent functions. Unfortunately, there's not much to comment on here since it's a subset of the previous RFC. Some notes:</p>
<h3 id="abstract-vs-anonymous">Abstract vs anonymous</h3>
<p>There are a few places here where the terminology around these types are questioned. I prefer &quot;abstract&quot; to draw a clearer separation between abstracted types and unnameable types, both of which could be confused as &quot;anonymous&quot; by non-experts (sorry @eddyb!).</p>
<h3 id="named-output-types">Named output types</h3>
<p><a href="https://github.com/eddyb">@eddyb</a> suggests naming the return types of functions, which is very similar to my suggestion for named unnameable types. Even down to the use of the <code>type</code> keyword, which was fun to see. Naming the return types of functions alone would make it possible to do everything that type alias <code>as impl Trait</code> can do, but using it in conjunction with type aliases would give us incredibly comfy ergonomics.</p>
<h3 id="anxiety-of-impl-trait-overuse">Anxiety of <code>impl Trait</code> overuse</h3>
<p>The downsides of <code>impl Trait</code> are known, and a few people pointed out that encouraging the use of <code>impl Trait</code> in more places could lead to undesirable situations. We discussed this problem when we talked about whether we want our trait implementations to leak, and I think that <code>as impl Trait</code> alleviates many of these concerns by preserving the concrete type information.</p>
<h3 id="bikeshedding-impl-vs-type">Bikeshedding: <code>impl</code> vs <code>type</code></h3>
<p>There seem to be some strong opinions about which syntax would be better. <code>impl Trait</code> won evidently.</p>
<h3 id="an-unclear-future-for-impl-trait">An unclear future for <code>impl Trait</code></h3>
<p>A really poignant critique of the RFC was that the original failed because many people wanted different futures for it. This RFC was effectively just the lowest common denominator, but doesn't resolve the question of which future <code>impl Trait</code> should have. This is exactly the same problem that I aim to address with <code>as impl Trait</code>.</p>
<h3 id="for-blocks"><code>for</code> blocks</h3>
<p><a href="https://github.com/glaebhoerl">@glaebhoerl</a> suggests using <code>for</code> blocks to desugar return-position <code>impl Trait</code> for generic free functions. It's a cool idea, but doesn't get much further exploration as the RFC period was winding down.</p>
<h2 id="expanded-impl-trait">Expanded <code>impl Trait</code></h2>
<p><a href="https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html">This RFC</a>, in essence, took on all the bikeshedding that wasn't ultimately essential to the first RFC. It does manage to introduce <code>impl Trait</code> in argument position, resolve bikeshedding around syntax, and come to a conclusion about type and lifetime parameters interacting with <code>impl Trait</code>.</p>
<p>There's honestly not too much to discuss here that hasn't already been discussed. Most of this RFC is consensus building and cornering <code>impl Trait</code> to prevent it from getting out of hand. This is a valuable RFC to read if you want to understand the specific semantics of <code>impl Trait</code>.</p>
<h2 id="impl-trait-existential-types"><code>impl Trait</code> existential types</h2>
<p>We've finally caught up and are moving on to the more experimental RFCs. <a href="https://rust-lang.github.io/rfcs/2071-impl-trait-existential-types.html">This RFC</a> aims to introduce <em>existential types</em> and expand <code>impl Trait</code> to more places. I have some real critiques of this RFC, so let's get into them.</p>
<h3 id="as-impl-trait-in-spirit"><code>as impl Trait</code> in spirit</h3>
<p>One of the first sections of this RFC suggests this syntax for abstracted types:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let</span><span> displayable: </span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Display = &quot;Hello, world!&quot;;</span><span>
</span></code></pre>
<p>This doesn't include the concrete underlying type, and so I think this would be much clearer as:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let</span><span> displayable: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str as impl </span><span>Display = &quot;Hello, world!&quot;;</span><span>
</span><span style="font-style:italic;color:#969896;">// or, with variable type inference</span><span>
</span><span>let displayable: _ as impl Display = &quot;Hello, world!&quot;;</span><span>
</span></code></pre>
<p>This addresses the same problems, but with an arguably clearer syntax:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#969896;">// Concrete</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">const </span><span style="color:#0086b3;">DISPLAYABLE</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str = </span><span style="color:#183691;">&quot;Hello, world!&quot;</span><span>;</span><span>
</span><span style="font-style:italic;color:#969896;">// Abstract</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">const </span><span style="color:#0086b3;">DISPLAYABLE</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str as impl </span><span>Display = &quot;Hello, world!&quot;;</span><span>
</span></code></pre>
<p>And can handle unnameable types with local inference:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">const </span><span style="color:#0086b3;">MY_CLOSURE</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">_ as impl </span><span>Fn(i32) -&gt; i32 = |x| x + 1;</span><span>
</span></code></pre>
<h3 id="existential-types">Existential types</h3>
<p>This section in particular muddies the water with <code>impl Trait</code>. The introduction of existential types is <em>intended</em> to provide the same type-abstracting functionality as <code>impl Trait</code>, but with the added benefit of being usable in more positions. There is a particular focus on type aliases and associated types, where the concrete underlying type is inferred based on its use.</p>
<p>I believe that inferring this concrete type is a mistake, and leads to the same inference issues discussed in the last post. Additionally, there is a large focus on not naming the concrete type to prevent trait impls from leaking. However I think this confuses the abstraction of a type with the naming of it. It's clearer to name a type and explicitly abstract it.</p>
<p>Fundamentally, I believe that existential types are a less clear formulation of <code>as impl Trait</code>. That's a very subjective opinion.</p>
<h2 id="type-alias-impl-trait">Type alias impl trait</h2>
<p>Finally, <a href="https://rust-lang.github.io/rfcs/2515-type_alias_impl_trait.html">this RFC</a> is nice and light. It simply builds on the existential types RFC by explicitly setting the syntax to use <code>impl Trait</code>. There is a lot of language lawyering and nailing down the very specific semantics, and it does a good job of explaining why additional syntax hinders learnability and results in confusion. We've already discussed the pros and cons of this RFC extensively, and I think we can do better.</p>
<h2 id="conclusion-1">Conclusion</h2>
<p><code>impl Trait</code> has taken a long journey to reach where it is now. Along the way there has been great ambition, as well as great confusion. I understand that there are very strong convictions on both sides, and I hope that we can use this as an opportunity to finally resolve them.</p>
<p>In my <a href="https://david.kolo.ski/blog/a-new-impl-trait-4/">final post</a>, I hope to bring the past three posts together into a coherent framework and provide a final recommendation on what should be done with <code>impl Trait</code>. If you've made it this far, I appreciate it a lot and hope you can hang on for just a little while longer.</p>

</div>
<div class="section navigation">
    
        Previous article: <a href="https:&#x2F;&#x2F;david.kolo.ski&#x2F;blog&#x2F;a-new-impl-trait-2&#x2F;">A new impl Trait 2/4</a>
    
    
        Next article: <a href="https:&#x2F;&#x2F;david.kolo.ski&#x2F;blog&#x2F;a-new-impl-trait-4&#x2F;">A new impl Trait 4/4</a>
    
</div>

    <div class="section footer">
        &copy; 2022 David Koloski
        <a href="/atom.xml"><img width="16" height="16" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 455 455'%3E%3Cpath d='M0 0v455h455V0H0zm141.435 372.387c-7.656 7.59-18.047 12.219-29.614 12.219-11.555 0-21.945-4.646-29.549-12.219C74.681 364.801 70 354.462 70 342.961s4.681-21.875 12.272-29.483c7.621-7.569 17.994-12.237 29.549-12.237 11.567 0 21.958 4.668 29.579 12.254 7.621 7.621 12.272 17.964 12.307 29.466-.035 11.501-4.686 21.822-12.272 29.426zM217.468 385s0-.101-.017-.101c-.066-39.41-15.431-76.597-43.221-104.352-27.786-27.838-64.925-43.256-104.195-43.291v-60.139c57.299.035 109.169 23.327 146.833 61.014 37.651 37.682 60.944 89.565 60.996 146.869h-60.396zm107.24 0c-.105-140.495-114.196-254.774-254.572-254.879V70c86.817.035 165.432 35.359 222.495 92.422C349.659 219.485 384.965 298.165 385 385h-60.292z' fill-rule='evenodd' fill='%23fff'/%3E%3C/svg%3E"></a>
    </div>
</body>
</html>