<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Software Engineer, Game Designer, Web Developer">
    <meta name="author" content="David Koloski">

    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="theme-color" content="#ffffff">

    <!-- fonts and styles -->
    <link href="https://fonts.googleapis.com/css?family=Rubik:400,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata:500,800" rel="stylesheet">
    <link href="https://davidkoloski.me/style.css" rel="stylesheet">

    <!-- scripts -->
    <script src="/elasticlunr.min.js" async></script>
    <script src="/search_index.en.js" async></script>
    <script src="/search.js" async></script>

    <title>
        
            Abstract Types in Rust 4
        
    </title>
</head>
<body>
    <div class="section header">
        <div class="logo">
            <a href="/" class="logo-image" width="100"></a>
        </div>
        <div class="links">
            
            
                <a href="https://davidkoloski.me/about/">About</a>
            
                <a href="https://davidkoloski.me/resume/">Resume</a>
            
            
                
                <a href="https://davidkoloski.me/blog/">Blog</a>
            
        </div>
        <div class="search">
            <input id="search-checkbox" type="checkbox" autocomplete="off">
            <input id="search-input" type="text" placeholder="Search">
            <label id="search-show" for="search-checkbox"></label>
        </div>
    </div>
    
<div class="section title">
    Abstract Types in Rust 4
    <div class="subtitle">
        Cutting the gordian <code>impl Trait</code>
    </div>
    <div class="subtitle">
        Mar  2, 2022 &ndash; 9 min read
    </div>
</div>
<div class="section taxonomies">
    
    <div class="categories">
        
            <a href="https://davidkoloski.me/categories/rust/">Rust</a>
        
    </div>
    
    <div class="tags">
        
            <a href="https://davidkoloski.me/tags/rust/">Rust</a>
        
    </div>
    
</div>
<div class="section content">
    <h2>This post is not ready to share yet</h2>
<p>This post is still undergoing review and critique. If you're here by chance or follow the <a href="/atom.xml">RSS feed</a>, please do not share this post yet. It will be ready soon!</p>
<h2 id="the-right-frame-of-mind">The right frame of mind</h2>
<p>This post is the culmination of the previous three posts, which discussed the <a href="https://davidkoloski.me/blog/abstract-types-in-rust-1/">nature of <code>impl Trait</code></a>, <a href="https://davidkoloski.me/blog/abstract-types-in-rust-2/">how to improve it</a>, and <a href="https://davidkoloski.me/blog/abstract-types-in-rust-3/">prior work on <code>impl Trait</code></a>. Finally, I will give my formal recommendation on a path forward for <code>impl Trait</code>.</p>
<h3 id="recap">Recap</h3>
<p>As a quick recap, I suggest introducing a new <code>as impl Trait</code> language feature that abstracts types in general. Augmented with named unnameable types, this change would enable all existing functionality while making code clearer and more orthogonal.</p>
<h2 id="stepping-stones">Stepping stones</h2>
<p>We've been breezing through many different examples and suggestions without really consolidating our knowledge. Let's take some time to build up some higher-level facts that we can use to inform our final analysis.</p>
<h3 id="the-lesser-of-two-evils">The lesser of two evils</h3>
<p>In this case, the two evils are <strong>type inference</strong> and <strong>named unnameable types</strong>. In order for <code>impl Trait</code> to function, we must choose one of these. Note that since we already have <code>impl Trait</code>, we have already chosen one of these (type inference). Having worked through some of the consequences, I do not pretend to know which would be cleaner, clearer, and most in line with Rust design goals. Let's consult a motivating example:</p>
<p>I would like to have some function <code>a</code> return a closure that yields some given value. Then, I would like to have some function <code>b</code> call <code>a</code> with a predefined value and return the same type. <code>a</code>'s return type must either be <em>inferred</em> or <em>named</em>.</p>
<h4 id="inferred">Inferred</h4>
<p>If <code>a</code>'s return type is inferred, then <code>b</code> must either:</p>
<ul>
<li>Refer to <code>a</code> to name its return type (i.e. <code>fn b() -&gt; &lt;a as Fn&lt;(T,)&gt;&gt;::Output</code>)</li>
<li>Infer it from its body (i.e. <code>fn b() -&gt; _</code>)</li>
</ul>
<p>A type alias doesn't change the situation here, as it would also either state <code>type Output = &lt;a as Fn(T)&gt;::Output</code> or <code>type Output = _</code>.</p>
<p>In the case of inference, we end up long-range type inference and spooky action at a distance. This proposal has the additional downside that it opens the door for inference to be used in places where it's not strictly necessary. This could lead to further confusion and would render the feature more harm than good.</p>
<p>In the case of function outputs, we end up with <code>a</code> only performing local inference which is arguably better. However, we suffer from the explicit function output signature, especially when we want to change the definition of <code>a</code>. Modifying its arguments would require modifying the type signature of <code>b</code> (or equivalently, the signature of the type alias) even when the return type has not changed. It makes maintenance more difficult at the same time as making discoverability more difficult.</p>
<h4 id="named">Named</h4>
<p>If we can name <code>a</code>'s return type, then <code>b</code> can just refer to that:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">a</span><span>&lt;T&gt;(value: T) -&gt; type </span><span style="font-weight:bold;color:#a71d5d;">&#39;Closure</span><span>&lt;T&gt; {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">&#39;Closure&lt;</span><span>T</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">move ||</span><span> value</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">b</span><span>() -&gt; type </span><span style="font-weight:bold;color:#a71d5d;">&#39;Closure</span><span>&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span>&gt; {</span><span>
</span><span>    </span><span style="color:#62a35c;">a</span><span>(</span><span style="color:#0086b3;">42</span><span>)</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This opens up new possibilities with closures, and extends nicely to async blocks which are the other main unnameable type. This also alleviates a major problem with naming these types, which was previously done by creating a type alias and using inference to achieve the same result.</p>
<p>The obvious downside is that this breaks encapsulation. This is not to be taken lightly, and I don't intend to take it so. There are also some very thorny questions regarding generics for closures that depend on type arguments. As a result, making such a change must not be required for <code>as impl Trait</code> and should be kept as a separable clause.</p>
<h3 id="how-opaque-are-abstract-types">How opaque are abstract types?</h3>
<p>With a new syntax <code>as impl Trait</code> to perform type abstraction, we need to figure out some fundamental questions:</p>
<h4 id="are-all-i32-as-impl-debug-the-same-type">Are all <code>i32 as impl Debug</code> the same type?</h4>
<p>As an example:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">a</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span> as impl Debug {</span><span>
</span><span>    </span><span style="color:#0086b3;">42</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">b</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span> as impl Debug {</span><span>
</span><span>    </span><span style="color:#0086b3;">10</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Could we compare <code>a() == b()</code>? Or after stating <code>let mut x = a()</code> set <code>x = b()</code>? These run contrary to the idea that <code>as impl Trait</code> creates a new type that only exposes a minimum of traits and information, so the answer here must be <em>no</em>. This leads naturally to the idea of <code>as impl Debug</code> as the desugaring site for abstraction itself:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>A&lt;T: Debug&gt;(T);</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">a</span><span>() -&gt; A&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span>&gt; {</span><span>
</span><span>    A(</span><span style="color:#0086b3;">42</span><span>)</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span>B&lt;T: Debug&gt;(T);</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">b</span><span>() -&gt; B&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span>&gt; {</span><span>
</span><span>    B(</span><span style="color:#0086b3;">10</span><span>)</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Now it is evident that <code>a</code> and <code>b</code> do not return types that can be meaningfully compared or exchanged. To unify them:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">type </span><span>Output </span><span style="font-weight:bold;color:#a71d5d;">= i32 as impl </span><span>Debug;</span><span>
</span><span>
</span><span>fn a() -&gt; Output {</span><span>
</span><span>    </span><span style="color:#0086b3;">42</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">b</span><span>() -&gt; Output {</span><span>
</span><span>    </span><span style="color:#0086b3;">10</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Would then desugar to:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Output&lt;T: Debug&gt;(T);</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">a</span><span>() -&gt; Output&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span>&gt; {</span><span>
</span><span>    Output(</span><span style="color:#0086b3;">42</span><span>)</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">b</span><span>() -&gt; Output&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span>&gt; {</span><span>
</span><span>    Output(</span><span style="color:#0086b3;">10</span><span>)</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>In which case we can see that the return values of <code>a</code> and <code>b</code> can support those operations.</p>
<h4 id="unnamed-in-return-position">Unnamed in return position</h4>
<p>It's worth noting that this still suffers from the same composability restrictions that <code>impl Trait</code> does in return position:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#969896;">// crate `a`</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">a</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span> as impl Debug { </span><span style="color:#0086b3;">42 </span><span>}</span><span>
</span><span>
</span><span style="font-style:italic;color:#969896;">// crate `b`</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">b</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">?? </span><span>{ </span><span style="color:#62a35c;">a</span><span>() }</span><span>
</span></code></pre>
<p>Because <code>b</code> must return the same type as <code>a</code>, it needs some way to return to <code>a</code>'s return type. The most commonly suggested way to do this is to use <code>Fn</code> traits:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">b</span><span>() -&gt; &lt;a </span><span style="font-weight:bold;color:#a71d5d;">as </span><span style="color:#0086b3;">Fn</span><span>&lt;()&gt;&gt;::Output { </span><span style="color:#62a35c;">a</span><span>() }</span><span>
</span></code></pre>
<p>Which works, but suffers from the verbosity of the syntax. This is a problem already discussed as a feature of a type-inferent solution to <code>impl Trait</code>, so this example may motivate that as a more complete approach.</p>
<h2 id="final-proposal">Final proposal</h2>
<p>Alright, with all that out of the way I can finally get around to my final recommendations. First, I'll talk about the theoretical ideal and where I think we could be at the end of the road. Second, I'll discuss how that will never happen and where we should set our expectations and exert our effort instead.</p>
<h3 id="the-zealot-s-guide-to-impl-trait">The zealot's guide to <code>impl Trait</code></h3>
<p>This is a maximally-offensive revision of <code>impl Trait</code>. This is where the evidence leads but implementing it would be insanely destructive. I recommend that we look to this for guidance but do not actually do this.</p>
<p>I believe that return position <code>impl Trait</code> should be deprecated entirely in favor of <code>as impl Trait</code>. Additionally, some way of naming the return value of a function should be settled on or <code>as impl Trait</code> should be banned in return position. This would effectively relegate it to syntax sugar for creating abstracted types, which is sufficiently simple. Remember that the <code>?</code> operator was a huge quality of life improvement and yet is relatively simple syntax sugar.</p>
<p>We must choose between inferring and explicit solutions to naming types, and they both have their pros and cons. Local inference could be used, but it will still require naming function return values. Any longer-range inference will just propagate type inference problems further. Explicitly naming unnameable types requires exotic syntax and may cause more problems than it solves by raising questions about syntax.</p>
<p><code>impl Trait</code> in argument position would be acceptable to keep, as its sugar is sufficiently simple and its purpose is orthogonal to other language features. I would be in support of removing it entirely to keep the language clean if others preferred that.</p>
<h3 id="the-engineer-s-guide-to-impl-trait">The engineer's guide to <code>impl Trait</code></h3>
<p>Now that that's out of our system, we can get down to business. We have some fundamentally conflicting and overlapping systems that we need to reconcile.</p>
<p>Because <code>as impl Trait</code> provides the functionality of type abstraction, we can now desugar <code>impl Trait</code> in return position to <code>_ as impl Trait</code> and allow the compiler to infer the concrete return type. This requires local inference, but we already had this and we're continuing to abstract the concrete type so this should all be above-board.</p>
<p>We may either allow <code>impl Trait</code> to desugar to <code>_ as impl Trait</code> and allow for nonlocal inference when used in type aliases (TAIT), or we may ban type inference for nameable types. I think that either outcome is acceptable and perhaps a lint for nameable inferred abstracted types would be the best path:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">type </span><span>Output </span><span style="font-weight:bold;color:#a71d5d;">= impl </span><span>Debug;</span><span>
</span><span style="font-style:italic;color:#969896;">//            ^^^^^^^^^^</span><span>
</span><span style="font-style:italic;color:#969896;">// WARNING: Output is nameable type `i32` and should be declared as:</span><span>
</span><span style="font-style:italic;color:#969896;">//   type Output = i32 as impl Debug;</span><span>
</span></code></pre>
<p>This would help push users to use the more explicit <code>as impl Trait</code> syntax and help prevent errors down the line from confusing inference situations. Similarly, we should ban or lint on <code>impl Trait</code> used on nameable types in return position:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; impl Debug {</span><span>
</span><span style="font-style:italic;color:#969896;">//             ^^^^^^^^^^</span><span>
</span><span style="font-style:italic;color:#969896;">// WARNING: return type is nameable type `i32` and should be declared as:</span><span>
</span><span style="font-style:italic;color:#969896;">//          fn target() -&gt; i32 as impl Debug</span><span>
</span><span>    </span><span style="color:#0086b3;">42</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>However we must acknowledge that there are still situations where we must allow closures and async blocks to take advantage of inference.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; impl Clone {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">|| </span><span style="color:#0086b3;">42</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>And if we want to allow local inference, perhaps a lint would be best in this case as well:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; impl Clone {</span><span>
</span><span style="font-style:italic;color:#969896;">//             ^^^^^^^^^^</span><span>
</span><span style="font-style:italic;color:#969896;">// WARNING: impl Trait is deprecated</span><span>
</span><span style="font-style:italic;color:#969896;">// NOTE:    use explicit inference instead: `_ as impl Clone`</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">|| </span><span style="color:#0086b3;">42</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>And finally, we must wait for consensus to be built for one of the naming candidates before we can have unabstracted unnameable types. It's sad, but it's reality and we have to acknowledge it.</p>
<p>A primary benefit of this proposal is that if we do come to a consensus on how to name unnameable types, we can very easily deprecate <code>impl Trait</code> completely. That would allow us to complete the transition and resolve many longstanding issues related to <code>impl Trait</code>.</p>
<h4 id="naming-options">Naming options</h4>
<p>The options I suggest for naming unnameable types are, in order from least to most radical:</p>
<ol>
<li><strong>Local return type inference plus <code>Fn</code> traits</strong>: I think the syntax is not great but tolerable.</li>
<li><strong>Named unnameable types</strong>: Potentially complex but much cleaner than LRTI + <code>Fn</code> traits.</li>
<li><strong>Nonlocal type inference</strong>: I think this brings so much baggage along with it that it will immediately stall out and fail. Death by a thousand RFC comments.</li>
</ol>
<p>I hope for #2 but realistically predict #1 if any of these succeed.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Whew, that was a lot of work. Hopefully I've gotten some gears turning and thoughts running. Let's have some lively debate about <code>impl Trait</code> and see if we can make Rust a better language for everyone.</p>
<p>Thanks to <a href="https://github.com/computerdruid">@computerdruid</a> and <a href="https://github.com/tmandry">@tmandry</a> in particular for reviewing this series of posts and helping me sharpen and deepen my understanding of <code>impl Trait</code>. I couldn't have done it without the help!</p>

</div>
<div class="section navigation">
    
        Previous article: <a href="https:&#x2F;&#x2F;davidkoloski.me&#x2F;blog&#x2F;abstract-types-in-rust-3&#x2F;">Abstract Types in Rust 3</a>
    
    
</div>

    <div class="section footer">
        &copy; 2022 David Koloski
        <a href="/atom.xml"><img width="16" height="16" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 455 455'%3E%3Cpath d='M0 0v455h455V0H0zm141.435 372.387c-7.656 7.59-18.047 12.219-29.614 12.219-11.555 0-21.945-4.646-29.549-12.219C74.681 364.801 70 354.462 70 342.961s4.681-21.875 12.272-29.483c7.621-7.569 17.994-12.237 29.549-12.237 11.567 0 21.958 4.668 29.579 12.254 7.621 7.621 12.272 17.964 12.307 29.466-.035 11.501-4.686 21.822-12.272 29.426zM217.468 385s0-.101-.017-.101c-.066-39.41-15.431-76.597-43.221-104.352-27.786-27.838-64.925-43.256-104.195-43.291v-60.139c57.299.035 109.169 23.327 146.833 61.014 37.651 37.682 60.944 89.565 60.996 146.869h-60.396zm107.24 0c-.105-140.495-114.196-254.774-254.572-254.879V70c86.817.035 165.432 35.359 222.495 92.422C349.659 219.485 384.965 298.165 385 385h-60.292z' fill-rule='evenodd' fill='%23fff'/%3E%3C/svg%3E"></a>
    </div>
</body>
</html>