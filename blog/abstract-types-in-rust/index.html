<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Software Engineer, Game Designer, Web Developer">
    <meta name="author" content="David Koloski">

    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="theme-color" content="#ffffff">

    <!-- fonts and styles -->
    <link href="https://fonts.googleapis.com/css?family=Rubik:400,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata:500,800" rel="stylesheet">
    <link href="https://davidkoloski.me/style.css" rel="stylesheet">

    <!-- scripts -->
    <script src="/elasticlunr.min.js" async></script>
    <script src="/search_index.en.js" async></script>
    <script src="/search.js" async></script>

    <title>
        
            Abstract Types in Rust
        
    </title>
</head>
<body>
    <div class="section header">
        <div class="logo">
            <a href="/" class="logo-image" width="100"></a>
        </div>
        <div class="links">
            
            
                <a href="https://davidkoloski.me/about/">About</a>
            
                <a href="https://davidkoloski.me/resume/">Resume</a>
            
            
                
                <a href="https://davidkoloski.me/blog/">Blog</a>
            
        </div>
        <div class="search">
            <input id="search-checkbox" type="checkbox" autocomplete="off">
            <input id="search-input" type="text" placeholder="Search">
            <label id="search-show" for="search-checkbox"></label>
        </div>
    </div>
    
<div class="section title">
    Abstract Types in Rust
    <div class="subtitle">
        impl Trait was born wrong, but we can make it right
    </div>
    <div class="subtitle">
        Feb 19, 2022 &ndash; 13 min read
    </div>
</div>
<div class="section taxonomies">
    
    <div class="tags">
        
            <a href="https://davidkoloski.me/tags/rust/">Rust</a>
        
    </div>
    
    <div class="categories">
        
            <a href="https://davidkoloski.me/categories/rust/">Rust</a>
        
    </div>
    
</div>
<div class="section content">
    <h2 id="this-post-is-not-ready-to-share-yet">This post is not ready to share yet</h2>
<p>This post is still undergoing review and critique. If you're here by chance or follow the RSS feed, please do not share this post yet. It will be ready soon!</p>
<h2 id="foreword">Foreword</h2>
<p>This article is both an explanation and criticism of <code>impl Trait</code>. A large portion of this text is dedicated to explaining and understanding the properties of <code>impl Trait</code>, but it is not <em>solely</em> an explainer. If you're already familiar with the properties and mechanics of <code>impl Trait</code>, you can skip to <a href="https://davidkoloski.me/blog/abstract-types-in-rust/#impl-trait-and-a-new-type-abstraction-operator">this section</a> to get to the meat of the criticism and the new ideas.</p>
<p>I believe that the current implementation of <code>impl Trait</code> is confusing and non-orthogonal. I propose an alternative formulation of <code>impl Trait</code> that is more intuitive, restores orthogonality to the feature, and enables more precise and flexible use of abstraction.</p>
<h2 id="what-is-impl-trait">What is <code>impl Trait</code>?</h2>
<p><code>impl Trait</code> is syntax sugar can be used in argument position or in return position. Let's look at how it can be used and how it desugars to more fundamental Rust syntax.</p>
<h3 id="argument-position">Argument position</h3>
<p>When used in argument position, <code>impl Trait</code> is shorthand for a type that implements the requested traits. It takes a function like:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">log</span><span>(x: impl Debug) {
</span><span>    dbg!(x);
</span><span>}
</span></code></pre>
<p>And desugars it to:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">log</span><span>&lt;X: Debug&gt;(x: X) {
</span><span>    dbg!(x);
</span><span>}
</span></code></pre>
<p>In argument position, each <code>impl Trait</code> is assumed to be a different, unique type. If we wanted to take <em>two</em> arguments of the same type, we couldn't use <code>impl Trait</code> any more and would have to be more explicit. This doesn't work:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">pick</span><span>(which: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>, x: impl Debug, y: impl Debug) -&gt; impl Debug {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if !</span><span>which {
</span><span>        x
</span><span>    } </span><span style="font-weight:bold;color:#a71d5d;">else </span><span>{
</span><span>        y
</span><span>    }
</span><span>}
</span></code></pre>
<p>With this error:</p>
<pre style="background-color:#ffffff;color:#323232;"><code><span>error[E0308]: `if` and `else` have incompatible types
</span><span>= note:        expected type `impl Debug`
</span><span>        found type parameter `impl Debug`
</span><span>= note: a type parameter was expected, but a different one was found
</span></code></pre>
<p>Because <code>x</code>'s <code>impl Debug</code> could be a different concrete type from <code>y</code>'s <code>impl Debug</code>. Instead, we must write:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">pick</span><span>&lt;T: Debug&gt;(which: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>, x: T, y: T) -&gt; T {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>}
</span></code></pre>
<p>Which tells the compiler that we expect two of the same type and will return that type. That's easy enough, we just have to desugar it ourselves and give the compiler a little more information. Let's move on.</p>
<h3 id="return-position">Return position</h3>
<p>When used in return position, <code>impl Traits</code> is <em>also</em> shorthand for a type that implements the requested traits. However, there's a catch. It takes a function like:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; impl Debug {
</span><span>    </span><span style="color:#183691;">&quot;hello world&quot;
</span><span>}
</span></code></pre>
<p>And desugars it to something like:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Target&lt;T: Debug </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="background-color:#f5f5f5;font-weight:bold;color:#b52a1d;">?</span><span>Sized&gt;(T);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span>&lt;T: Debug </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="background-color:#f5f5f5;font-weight:bold;color:#b52a1d;">?</span><span>Sized&gt; Debug for Target&lt;T&gt; {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">fmt</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self, f: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span>Formatter&lt;&#39;</span><span style="font-weight:bold;color:#a71d5d;">_</span><span>&gt;) -&gt; </span><span style="color:#0086b3;">Result</span><span>&lt;(), Error&gt; {
</span><span>        self.</span><span style="color:#0086b3;">0.</span><span style="color:#62a35c;">fmt</span><span>(f)
</span><span>    }
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; Target&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str</span><span>&gt; {
</span><span>    Target(</span><span style="color:#183691;">&quot;hello world&quot;</span><span>)
</span><span>}
</span></code></pre>
<p>This desugaring has a special property: the return type gets <em>abstracted</em>. Let's contrast this with an <em>unabstracted</em> return type:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str </span><span>{
</span><span>    </span><span style="color:#183691;">&quot;hello world&quot;
</span><span>}
</span></code></pre>
<p>There's a subtle but important difference between these two implementations. Normally, if you know the concrete type arguments to a function then you can deduce the corresponding concrete return type. Take this code for example:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">combine</span><span>&lt;T: Add&gt;(lhs: T, rhs: T) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">T::</span><span>Output {
</span><span>    lhs.</span><span style="color:#62a35c;">add</span><span>(rhs)
</span><span>}
</span><span>
</span><span>println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span>, </span><span style="color:#62a35c;">combine</span><span>(</span><span style="color:#0086b3;">1</span><span>, </span><span style="color:#0086b3;">2</span><span>));
</span></code></pre>
<p>Notice how <code>combine</code> doesn't guarantee <code>T::Output: Display</code>? That means there's no guarantee that <code>combine</code> returns something that implements <code>Display</code>, right? What's going on?</p>
<p>In this situation, the compiler is deducing the concrete return type of <code>combine</code> at the call site and then checking whether <em>that</em> type implements <code>Display</code>. We know that <code>combine(i32, i32)</code> will return an <code>i32</code>, and <code>i32</code> implements <code>Display</code>, so we have deduced that the return value of that specific call to <code>combine</code> will return something that implements <code>Display</code>. Problem solved!</p>
<p>Abstraction prevents this kind of introspection by wrapping the output in an <em>abstract</em> wrapper type. In the previous example, the <code>Target</code> type proxied the <code>Debug</code> impl but <em>only</em> the <code>Debug</code> impl. Any other traits implemented by the wrapped <code>T</code> are <em>not</em> implemented by <code>Target&lt;T&gt;</code>, which prevents that type introspection. An alternate implementation of <code>combine</code> that uses <code>impl Trait</code> might look like this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">combine</span><span>&lt;T: Add&gt;(lhs: T, rhs: T) -&gt; impl Display
</span><span style="font-weight:bold;color:#a71d5d;">where
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">T::</span><span>Output: Display,
</span><span>{
</span><span>    lhs.</span><span style="color:#62a35c;">add</span><span>(rhs)
</span><span>}
</span><span>
</span><span>println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span>, </span><span style="color:#62a35c;">combine</span><span>(</span><span style="color:#0086b3;">1</span><span>, </span><span style="color:#0086b3;">2</span><span>));
</span></code></pre>
<p>So everything still works like we expect. The difference comes when we do something like:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span>, </span><span style="color:#62a35c;">combine</span><span>(</span><span style="color:#0086b3;">1</span><span>, </span><span style="color:#0086b3;">2</span><span>));
</span></code></pre>
<p>In the unabstracted <code>combine</code>, we can deduce the concrete return type of <code>combine(1, 2)</code> and check whether it implements <code>Debug</code>. It does, so we can debug print it. However, in the abstracted <code>combine</code> we abstracted our return type and that abstracted type <em>does not</em> implement <code>Debug</code>. So this won't compile with the abstracted implementation.</p>
<p>So we actually have two options for our functions' return types. One of them is <em>unabstracted</em>, where the caller can introspect the concrete type and check whether it implements some unrelated traits. The other is <em>abstracted</em>, where we hide the concrete type from the caller in a wrapper and only expose exactly the traits that we choose to. That's the very literal difference between them, but what does that actually <em>mean</em>?</p>
<h2 id="should-you-abstract-your-types">Should you abstract your types?</h2>
<p>An abstract type restricts what someone else can know about some concrete type. In the <code>fn target() -&gt; Target</code> example, whoever calls <code>target</code> knows that it's not just returning any old <code>T: Debug</code>, it knows that it's returning exactly <code>&amp;'static str</code>. This can be both a blessing and a curse:</p>
<h3 id="blessings">Blessings</h3>
<p>On one hand, knowing exactly what type it is lets you reason about its other properties:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Wrapper&lt;T&gt;(T);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">wrap</span><span>&lt;T&gt;(value: T) -&gt; Wrapper&lt;T&gt; {
</span><span>    Wrapper(value)
</span><span>}
</span><span>
</span><span>println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span>, </span><span style="color:#62a35c;">wrap</span><span>(</span><span style="color:#183691;">&quot;hello world&quot;</span><span>));
</span></code></pre>
<p>So even though <code>wrap</code> doesn't guarantee that its return type implements <code>Debug</code>, we can figure out whether or not it does ourselves. This lets us &quot;leak&quot; our impls through the return type so we can be as helpful as possible with whoever calls our function.</p>
<h3 id="curses">Curses</h3>
<p>But some time in the future, we might change <code>Wrapper</code> so that it no longer implements <code>Debug</code>:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Wrapper&lt;T&gt;(T);
</span></code></pre>
<p>Oh no! That was just for debugging, nobody was supposed to rely on that being implemented! And now we've broken everyone who was relying on that trait. This situation gets worse for <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">auto traits</a> like <code>Send</code> and <code>Sync</code>, since we might change whether our type implements an auto trait just by changing its definition! That's spooky action at a distance!</p>
<p>This is a situation where abstraction can really help us. By limiting the introspection of our public types, we can prevent <a href="https://www.hyrumslaw.com/">Hyrum's Law</a> from breaking everything downstream from our library.</p>
<p>Hold on though, something's missing here. These have all been free functions; what happens if we do this in a trait?</p>
<h2 id="impl-trait-in-traits"><code>impl Trait</code> in traits</h2>
<h3 id="argument-position-traits">Argument position (traits)</h3>
<p>Not much is different for argument position <code>impl Trait</code> in trait methods. Something like this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Logger {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">log</span><span>(x: impl Debug);
</span><span>}
</span></code></pre>
<p>desugars to:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Logger {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">log</span><span>&lt;X: Debug&gt;(x: X);
</span><span>}
</span></code></pre>
<p>Nice and easy, uncontroversial. But what about...</p>
<h3 id="return-position-traits">Return position (traits)</h3>
<p>You can't use <code>impl Trait</code> in return position right now, but is that? Let's consider a desugaring of <code>impl Trait</code> as a return type in a trait:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; impl Ore;
</span><span>}
</span></code></pre>
<p>A straightforward desugaring of this would be:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Mine: Ore;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Mine;
</span><span>}
</span></code></pre>
<p>But that doesn't abstract the return type like we want. Instead, we should abstract that with a wrapper to hide the details of the concrete type:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>MinerOre&lt;T: Ore&gt;(T);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span>&lt;T: Ore&gt; Ore </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>MinerOre&lt;T&gt; { </span><span style="font-weight:bold;color:#a71d5d;">... </span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Mine: Ore;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; MinerOre&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Mine&gt;;
</span><span>}
</span></code></pre>
<p>Much better, this can be our canonical desugaring for now. Let's go implement a <code>Miner</code>:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Quarry;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Miner </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Quarry {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; impl Ore {
</span><span>        Bauxite
</span><span>    }
</span><span>}
</span></code></pre>
<p>Which would then desugar to:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Quarry;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Miner </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Quarry {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Mine </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> Bauxite;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; MinerOre&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Mine&gt; {
</span><span>        MinerOre(Bauxite)
</span><span>    }
</span><span>}
</span></code></pre>
<p>This makes sense, but something's not quite right here. The trait is dictating whether the return type of the function is abstract, but shouldn't the impl choose for itself whether to abstract its return type? After all, the impl is the one exposing that concrete type so it should also decide whether to let users introspect on it. Let's consider an alternative desugaring:</p>
<h3 id="return-position-traits-remixed">Return position (traits, remixed)</h3>
<p>Let's change our original desugaring for our trait:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; impl Ore;
</span><span>}
</span></code></pre>
<p>So that it now desugars to:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Mine: Ore;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Mine;
</span><span>}
</span></code></pre>
<p>Hmm, that <em>does</em> seem more consistent with how the argument position <code>impl Trait</code> desugars. Interesting, let's keep that in mind. Anyway, let's write our <code>Miner</code> impl now:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Quarry;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Miner </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Quarry {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; impl Ore {
</span><span>        Bauxite
</span><span>    }
</span><span>}
</span></code></pre>
<p>We can now desugar this to:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Quarry;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span>QuarryOre&lt;T: Ore&gt;(T);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span>&lt;T: Ore&gt; Ore </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>QuarryOre&lt;T&gt; { </span><span style="font-weight:bold;color:#a71d5d;">... </span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Miner </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Quarry {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Mine </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>QuarryOre&lt;Bauxite&gt;;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Mine {
</span><span>        QuarryOre(Bauxite)
</span><span>    }
</span><span>}
</span></code></pre>
<p>And now it's the <em>impl</em> that decides whether a return type should be abstract or not. Nice! Now we have a choice of whether or not to abstract our return type in our impl, but the syntax seems a little weird. If we chose not to abstract our return type, the trait and impl would look like this instead:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; impl Ore;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Quarry;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Miner </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Quarry {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Mine </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> Bauxite;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Mine {
</span><span>        Bauxite
</span><span>    }
</span><span>}
</span></code></pre>
<p>Yeah, that's really weird. There's no associated type in the trait definition, but we have to use it to write our unabstracted trait implementation. This is really confusing me, why doesn't the free function version of <code>impl Trait</code> have this problem?</p>
<p>Well actually, it does.</p>
<h3 id="return-position-remixed">Return position (remixed)</h3>
<p>Let's take a look at our <code>target</code> function again:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; impl Debug {
</span><span>    </span><span style="color:#183691;">&quot;hello world&quot;
</span><span>}
</span></code></pre>
<p>An alternative desugaring would be:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">type </span><span>Target: Debug </span><span style="font-weight:bold;color:#a71d5d;">= &amp;&#39;static str</span><span>;
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; Target {
</span><span>    </span><span style="color:#183691;">&quot;hello world&quot;
</span><span>}
</span></code></pre>
<p>That would be more consistent, wouldn't it? We aren't hiding the concrete return type, and we're bounding our return type with a trait. This is a lot more like the desugaring for <code>impl Trait</code> in argument position. We had to determine the concrete <code>Target</code> type alias ourselves though, which is a little tedious. Wouldn't it be nice if we could make the compiler do that for us?</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">type </span><span>Target: Debug </span><span style="font-weight:bold;color:#a71d5d;">= _</span><span>;
</span></code></pre>
<p>Much better, now we can let the compiler figure out the return type of <code>target</code>, ensure that it implements <code>Debug</code>, and return it unabstracted.</p>
<p>But this leads us to an important question: which of these should be the <em>real</em> <code>impl Trait</code>? From here on out, I'll present my <em>opinion</em> on this question and a possible solution to this problem. </p>
<h2 id="impl-trait-and-a-new-type-abstraction-operator"><code>impl Trait</code> and a new type abstraction operator</h2>
<p>I propose that the desugaring for <code>impl Trait</code> in return position should not abstract the return type, and instead a new operator should be introduced for performing type abstraction. Let me be explicit:</p>
<h3 id="a-new-desugaring">A new desugaring</h3>
<p><code>impl Trait</code> in return position should desugar from this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; impl Debug {
</span><span>    </span><span style="color:#183691;">&quot;hello world&quot;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; impl Ore;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Miner </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Quarry {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; impl Ore {
</span><span>        Bauxite
</span><span>    }
</span><span>}
</span></code></pre>
<p>To this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">_</span><span>: Debug {
</span><span>    </span><span style="color:#183691;">&quot;hello world&quot;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">_</span><span>: Ore;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Miner </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Quarry {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">_</span><span>: Ore {
</span><span>        Bauxite
</span><span>    }
</span><span>}
</span></code></pre>
<p>And finally into this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">type </span><span>Target: Debug </span><span style="font-weight:bold;color:#a71d5d;">= _</span><span>;
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">target</span><span>() -&gt; Target {
</span><span>    </span><span style="color:#183691;">&quot;hello world&quot;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Miner {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Mine: Ore;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Mine;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Miner </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Quarry {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Mine: Ore </span><span style="font-weight:bold;color:#a71d5d;">= _</span><span>;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mine</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Mine {
</span><span>        Bauxite
</span><span>    }
</span><span>}
</span></code></pre>
<p>This requires two new features:</p>
<ul>
<li>Bounds on type definitions (<code>type Target: Debug</code>, <code>type Mine: Ore</code>)</li>
<li>Type inference in type definitions (<code>type Target = _</code>, <code>type Mine = _</code>)</li>
</ul>
<p>We can emulate bounds with a construction like:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">assert_impls_debug</span><span>&lt;T: Debug&gt;() {}
</span><span style="font-weight:bold;color:#a71d5d;">let _ = </span><span>assert_impls_debug&lt;Target&gt;;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">assert_impls_ore</span><span>&lt;T: Ore&gt;() {}
</span><span style="font-weight:bold;color:#a71d5d;">let _ = </span><span>assert_impls_ore&lt;&lt;Quarry </span><span style="font-weight:bold;color:#a71d5d;">as</span><span> Miner&gt;::Mine&gt;;
</span></code></pre>
<p>Which works, albeit with some ugly errors. Type inference is a truly new feature, but it may be able to leverage existing infrastructure for deducing types. I also propose a restriction for inferred type definitions:</p>
<blockquote>
<p>Inferred type definitions that are not bounded or otherwise constrained (&quot;naked&quot; type inference) result in a compiler warning.</p>
</blockquote>
<p>With that out of the way, we can get on to the big change:</p>
<h3 id="as-impl-trait-as-the-type-abstraction-operator"><code>as impl Trait</code> as the type abstraction operator</h3>
<p>Consider this new syntax:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span>() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str</span><span> as impl Debug {
</span><span>    </span><span style="color:#183691;">&quot;hello world&quot;
</span><span>}
</span></code></pre>
<p>This new syntax would desugar to:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>ImplDebug&lt;T: Debug&gt;(T);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span>&lt;T: Debug&gt; Debug </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>ImplDebug&lt;T&gt; {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">fmt</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self, f: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span>Formatter&lt;&#39;</span><span style="font-weight:bold;color:#a71d5d;">_</span><span>&gt;) -&gt; </span><span style="color:#0086b3;">Result</span><span>&lt;(), Error&gt; {
</span><span>        self.</span><span style="color:#0086b3;">0.</span><span style="color:#62a35c;">fmt</span><span>(f)
</span><span>    }
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span>() -&gt; ImplDebug&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str</span><span>&gt; {
</span><span>    ImplDebug(</span><span style="color:#183691;">&quot;hello world&quot;</span><span>)
</span><span>}
</span></code></pre>
<p>This allows abstract types to be used anywhere a regular type would be, and not just in return position. It would separate the type abstraction of <code>impl Trait</code> in return position from the type inference of it in argument position and help solve a number of outstanding problems with type abstraction.</p>
<p>Let's take a look at some of those:</p>
<h2 id="problems-solved">Problems solved</h2>
<h3 id="return-position-impl-trait-in-trait-rpitit">Return position impl trait in trait (RPITIT)</h3>
<p>Associated types of traits leak concrete types. Someone might use <code>&lt;MyFoo as Foo&gt;::Bar</code> somewhere that it needs to be <code>Debug</code>, and the compiler will let them as long as it is. But that's not part of our contract, and nobody should be allowed to depend on the fact that <code>MyBar</code> implements <code>Debug</code> if we don't want them to. So what if we could say something like this instead:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">trait </span><span>Cloner&lt;T: Clone&gt; {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Cloned;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">duplicate</span><span>(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>T) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span>Cloned;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span>&lt;T: </span><span style="color:#0086b3;">Clone</span><span>&gt; Cloner&lt;T&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Printer {
</span><mark style="background-color:#f5f5f5;"><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Cloned </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> T </span><span style="font-weight:bold;color:#a71d5d;">as impl </span><span>Clone;
</span></mark><span>    fn duplicate(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>T) -&gt; Self::Cloned {
</span><span>        x.</span><span style="color:#62a35c;">clone</span><span>() </span><span style="font-weight:bold;color:#a71d5d;">as impl </span><span>Clone
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now, the associated <code>T</code> type isn't <code>T</code>, it's an <em>abstraction</em> of <code>T</code>. It's an abstraction that only exposes the fact that <code>T</code> implements <code>Clone</code>, which is exactly what we want.</p>
<h3 id="publicly-abstracted-private-types">Publicly abstracted private types</h3>
<p>With a little more elbow grease, this would also allow constructions like:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><mark style="background-color:#f5f5f5;"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Thought;
</span></mark><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>Brain;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Factory </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Brain {
</span><mark style="background-color:#f5f5f5;"><span>    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span>Output </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> Thought </span><span style="font-weight:bold;color:#a71d5d;">as impl </span><span>Display;
</span></mark><span>    fn produce() -&gt; Self::Output {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>    }
</span><span>}
</span></code></pre>
<p>Note that <code>Thought</code> is <em>private</em>, yet we're exposing it <em>through an abstraction</em> in our associated type. This makes it possible for us to swap out the concrete type of <code>&lt;Brain as Factory&gt;::Output</code> without it being a breaking change! <code>Thought</code> was private and inaccessible, and so we could remove it entirely without causing any semver violations.</p>
<h3 id="reusable-abstract-types">Reusable abstract types</h3>
<p>By leveraging our new type definition inference, we can use <code>as impl Trait</code> in type aliases:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><mark style="background-color:#f5f5f5;"><span style="font-weight:bold;color:#a71d5d;">pub type </span><span>Id </span><span style="font-weight:bold;color:#a71d5d;">= _ as impl </span><span>Hash + Eq;
</span></mark><span>
</span><span>pub fn generate_id() -&gt; Id { </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span>}
</span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">clone_id</span><span>(x: Id) -&gt; Id { </span><span style="font-weight:bold;color:#a71d5d;">... </span><span>}
</span></code></pre>
<p>This allows us to simultaneously abstract away the concrete type of <code>Id</code> while still guaranteeing that <code>generate_id</code> and <code>clone_id</code> return the same type.</p>
<h2 id="conclusion">Conclusion</h2>
<p>After reviewing the origins and inner workings of <code>impl Trait</code>, I have presented an alternative formulation of <code>impl Trait</code> that restores orthogonality to type inference and abstraction. I then outlined a new <code>as impl Trait</code> operator that performs type abstraction in more general contexts than <code>impl Trait</code> could. I believe these changes would make it easier to teach and use <code>impl Trait</code>, and lay a foundation for more complex functionality to build on.</p>
<p>Many of these ideas are not new, they have been discussed and considered before. However, I think we now have the experience necessary to fix our past mistakes and a growing need for these more general tools.</p>

</div>
<div class="section navigation">
    
        Previous article: <a href="https:&#x2F;&#x2F;davidkoloski.me&#x2F;blog&#x2F;anima-playground&#x2F;">Anima Playground</a>
    
    
</div>

    <div class="section footer">
        &copy; 2022 David Koloski
        <a href="/atom.xml"><img width="16" height="16" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 455 455'%3E%3Cpath d='M0 0v455h455V0H0zm141.435 372.387c-7.656 7.59-18.047 12.219-29.614 12.219-11.555 0-21.945-4.646-29.549-12.219C74.681 364.801 70 354.462 70 342.961s4.681-21.875 12.272-29.483c7.621-7.569 17.994-12.237 29.549-12.237 11.567 0 21.958 4.668 29.579 12.254 7.621 7.621 12.272 17.964 12.307 29.466-.035 11.501-4.686 21.822-12.272 29.426zM217.468 385s0-.101-.017-.101c-.066-39.41-15.431-76.597-43.221-104.352-27.786-27.838-64.925-43.256-104.195-43.291v-60.139c57.299.035 109.169 23.327 146.833 61.014 37.651 37.682 60.944 89.565 60.996 146.869h-60.396zm107.24 0c-.105-140.495-114.196-254.774-254.572-254.879V70c86.817.035 165.432 35.359 222.495 92.422C349.659 219.485 384.965 298.165 385 385h-60.292z' fill-rule='evenodd' fill='%23fff'/%3E%3C/svg%3E"></a>
    </div>
</body>
</html>