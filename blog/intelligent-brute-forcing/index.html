<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Software Engineer, Game Designer, Web Developer">
    <meta name="author" content="David Koloski">

    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="theme-color" content="#ffffff">

    <!-- fonts and styles -->
    <link href="https://fonts.googleapis.com/css?family=Rubik:400,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata:500,800" rel="stylesheet">
    <link href="https://david.kolo.ski/style.css" rel="stylesheet">

    <!-- scripts -->
    <script src="/elasticlunr.min.js" async></script>
    <script src="/search_index.en.js" async></script>
    <script src="/search.js" async></script>

    <title>
        
            Intelligent brute forcing
        
    </title>
</head>
<body>
    <div class="section header">
        <div class="logo">
            <a href="/" class="logo-image" width="100"></a>
        </div>
        <div class="links">
            
            
                <a href="https://david.kolo.ski/about/">About</a>
            
                <a href="https://david.kolo.ski/resume/">Resume</a>
            
            
                
                <a href="https://david.kolo.ski/blog/">Blog</a>
            
        </div>
        <div class="search">
            <input id="search-checkbox" type="checkbox" autocomplete="off">
            <input id="search-input" type="text" placeholder="Search">
            <label id="search-show" for="search-checkbox"></label>
        </div>
    </div>
    
<div class="section title">
    Intelligent brute forcing
    <div class="subtitle">
        Solving NP-hard puzzles with the oldest trick in the book
    </div>
    <div class="subtitle">
        Oct 10, 2021 &ndash; 22 min read
    </div>
</div>
<div class="section taxonomies">
    
    <div class="tags">
        
            <a href="https://david.kolo.ski/tags/rust/">Rust</a>,
        
            <a href="https://david.kolo.ski/tags/puzzles/">Puzzles</a>
        
    </div>
    
    <div class="categories">
        
            <a href="https://david.kolo.ski/categories/rust/">Rust</a>
        
    </div>
    
</div>
<div class="section content">
    <h2 id="a-little-background">A little background</h2>
<p>Back in college, I played a lot of <em>puzzle games</em>. When I talk about these kinds of games, I'm going
to be referring to a very specific subset of puzzle game. Some examples include:</p>
<ul>
<li><a href="https://store.steampowered.com/app/353540/Stephens_Sausage_Roll/">Stephen's Sausage Roll</a></li>
<li><a href="https://store.steampowered.com/app/207570/English_Country_Tune/">English Country Tune</a></li>
<li><a href="https://store.steampowered.com/app/290260/Sokobond/">Sokobond</a></li>
</ul>
<p>I was also fortunate to take Data Structures at RPI, where at the time professor Cutler (hi Barb!)
had a yearly assignment/competition where students to write a <em>puzzle solver</em>. The game changed
every year, and for my year the game was
<a href="https://www.cs.rpi.edu/academics/courses/fall13/csci1200/hw/06_ricochet_robots/hw.pdf">Ricochet Robots</a>,
which is essentially a sliding ice puzzle with multiple players. I really enjoyed the assignment
(and won the competition!) and continued to enter the competition as a TA. I probably went too hard
on it in retrospect; hopefully I wasn't too much of a nuisance!</p>
<p>Anyway, the purpose of the assignment was to get everyone familiar with recursion and depth-first
search. Your program would be given the initial state of the game as well as a maximum recursion
depth. The goal was to return either the shortest possible solution, or all possible solutions of
minimum length. For the competition, you may or may not be passed a depth limit and might also be
given puzzles that had no solution. I learned a lot and had a lot of fun, so maybe you will too.</p>
<h2 id="abstract">Abstract</h2>
<p>In this article, I will present a new puzzle game and demonstrate techniques I used to write a fast,
practical solver for it. Topics covered will include breadth-first/A* search, memoization,
optimization, and strategies specific to NP-hard and NP-complete puzzle games. If you spot any
problems or want to suggest any improvements, please file an issue or submit a PR
<a href="https://github.com/djkoloski/davidkoloski_me">on GitHub</a>. I will present benchmarks to validate my
results throughout. While the percentage changes should be relatively accurate, the absolute timings
may vary throughout as they are taken at different times with different amounts of baseline noise.
The pre-/post- change benchmarks are always run back-to-back to ensure that they are run in the same
environment and provide accurate percentage change.</p>
<h2 id="let-s-play-a-game">Let's play a game</h2>
<p>The game we're going to play is called &quot;Anima&quot;. It uses a grid of tiles, each of which is either
passable or impassable. Some tiles are marked with a small colored diamond; these tiles are <em>goals</em>
and to solve the puzzle we have to cover all of these tiles simultaneously with <em>actors</em> of the same
color. Actors are blocks, at most one per tile, that can be moved around the grid on the passable
tiles. Each turn, you may move the actors in one of the four cardinal directions and they all slide
together. Let's do a few to get a feel for it:</p>
<div class="center"><div><h3 id="controls">Controls</h3>
<ul>
<li><strong>Move</strong>: WASD/Arrow keys (desktop), swipe (mobile)</li>
<li><strong>Undo</strong>: Space (desktop), top left button</li>
<li><strong>Reset</strong>: Shift + Space (desktop), bottom left button</li>
<li><strong>Unfocus</strong>: Escape (desktop), click away, tap (mobile)</li>
</ul>
</div></div>

<script>
    let wasm_bindgen;
(function() {
    const __exports = {};
    let wasm;

    let WASM_VECTOR_LEN = 0;

    let cachegetUint8Memory0 = null;
    function getUint8Memory0() {
        if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
            cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        }
        return cachegetUint8Memory0;
    }

    let cachedTextEncoder = new TextEncoder('utf-8');

    const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
        ? function (arg, view) {
        return cachedTextEncoder.encodeInto(arg, view);
    }
        : function (arg, view) {
        const buf = cachedTextEncoder.encode(arg);
        view.set(buf);
        return {
            read: arg.length,
            written: buf.length
        };
    });

    function passStringToWasm0(arg, malloc, realloc) {

        if (realloc === undefined) {
            const buf = cachedTextEncoder.encode(arg);
            const ptr = malloc(buf.length);
            getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
            WASM_VECTOR_LEN = buf.length;
            return ptr;
        }

        let len = arg.length;
        let ptr = malloc(len);

        const mem = getUint8Memory0();

        let offset = 0;

        for (; offset < len; offset++) {
            const code = arg.charCodeAt(offset);
            if (code > 0x7F) break;
            mem[ptr + offset] = code;
        }

        if (offset !== len) {
            if (offset !== 0) {
                arg = arg.slice(offset);
            }
            ptr = realloc(ptr, len, len = offset + arg.length * 3);
            const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
            const ret = encodeString(arg, view);

            offset += ret.written;
        }

        WASM_VECTOR_LEN = offset;
        return ptr;
    }

    let cachegetInt32Memory0 = null;
    function getInt32Memory0() {
        if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
            cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
        }
        return cachegetInt32Memory0;
    }

    function getArrayI32FromWasm0(ptr, len) {
        return getInt32Memory0().subarray(ptr / 4, ptr / 4 + len);
    }
    /**
    * @param {string} puzzle
    * @returns {Int32Array | undefined}
    */
    __exports.solve = function(puzzle) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            var ptr0 = passStringToWasm0(puzzle, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            wasm.solve(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayI32FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 4);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    };

    async function load(module, imports) {
        if (typeof Response === 'function' && module instanceof Response) {
            if (typeof WebAssembly.instantiateStreaming === 'function') {
                try {
                    return await WebAssembly.instantiateStreaming(module, imports);

                } catch (e) {
                    if (module.headers.get('Content-Type') != 'application/wasm') {
                        console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                    } else {
                        throw e;
                    }
                }
            }

            const bytes = await module.arrayBuffer();
            return await WebAssembly.instantiate(bytes, imports);

        } else {
            const instance = await WebAssembly.instantiate(module, imports);

            if (instance instanceof WebAssembly.Instance) {
                return { instance, module };

            } else {
                return instance;
            }
        }
    }

    async function init(input) {
        if (typeof input === 'undefined') {
            let src;
            if (typeof document === 'undefined') {
                src = location.href;
            } else {
                src = document.currentScript.src;
            }
            input = src.replace(/\.js$/, '_bg.wasm');
        }
        const imports = {};


        if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
            input = fetch(input);
        }



        const { instance, module } = await load(await input, imports);

        wasm = instance.exports;
        init.__wbindgen_wasm_module = module;

        return wasm;
    }

    wasm_bindgen = Object.assign(init, __exports);

})();

</script>

<script>
    const PLAYGROUND_URL = 'http://david.kolo.ski/blog/anima-playground'

window.addEventListener('load', async (event) => {
  await wasm_bindgen('/wasm/anima_solver_bg.wasm')

  for (let json of document.getElementsByClassName('anima-data')) {
    let puzzle = {
      data: JSON.parse(json.text),
      scale: Number(json.getAttribute('data-scale')),
      controls: json.getAttribute('data-controls') === 'true'
    }

    let params = new URL(document.location).searchParams

    let data = params.get('data')
    let scale = params.get('scale')
    let controls = params.get('controls')

    if (json.getAttribute('data-dynamic') === 'true' && data != null) {
      console.log(data)
      puzzle.data = JSON.parse(atob(data))
    }
    if (scale != null) {
      puzzle.scale = Number(scale)
    }
    if (controls === 'true') {
      puzzle.controls = true
    }

    json.insertAdjacentElement(
      'afterend',
      new Puzzle(puzzle)
    )
  }
})

class CustomElement extends HTMLElement {
  constructor (name, props, data) {
    super()

    const template = document.getElementById(name + '-template')
    this.attachShadow({ mode: 'open' }).appendChild(template.content.cloneNode(true))

    this.refs = {}
    for (let ref of this.shadowRoot.querySelectorAll('[data-ref]')) {
      this.refs[ref.getAttribute('data-ref')] = ref
    }

    this._props = props || this.props
    Object.defineProperty(this, 'props', {
      get () {
        return this._props
      },
      set (value) {
        this._props = value
        this.update()
      }
    })

    if (data != null) {
      for (let key in data) {
        this[key] = data[key]
      }
    }

    if (this._props !== undefined) {
      this.update()
    }
  }

  update () {}
}

class Actor extends CustomElement {
  constructor (props) {
    super('anima-actor', props)
  }

  update () {
    switch (this.props.color) {
      case 'red':
        this.classList.add('red')
        break
      case 'blue':
        this.classList.add('blue')
        break
      default:
        throw new Error(`Invalid color ${this.props.color}`)
    }

    this.style.width = `${this.props.scale}px`
    this.style.height = `${this.props.scale}px`
    this.style.transform = `translate(${this.props.x * this.props.scale}px, ${(this.props.height - this.props.y - 1) * this.props.scale}px)`
  }
}
window.customElements.define('anima-actor', Actor)

class Puzzle extends CustomElement {
  constructor (props) {
    super('anima-puzzle', props)

    this.deactivate()

    this.refs.board.addEventListener('focus', e => this.activate())
    this.refs.board.addEventListener('blur', e => this.deactivate())

    this.touch = {}
    this.refs.board.addEventListener('touchstart', e => {
      if (this.active) {
        this.touch.startX = e.targetTouches[0].clientX
        this.touch.startY = e.targetTouches[0].clientY
        this.touch.done = false
        e.preventDefault()
      }
    })
    this.refs.board.addEventListener('touchmove', e => {
      if (this.active) {
        if (!this.touch.done) {
          let dx = e.targetTouches[0].clientX - this.touch.startX
          let dy = e.targetTouches[0].clientY - this.touch.startY

          const SWIPE_DIST = 40
          if (dx < -SWIPE_DIST) {
            this.move(-1, 0)
            this.touch.done = true
          } else if (dx > SWIPE_DIST) {
            this.move(1, 0)
            this.touch.done = true
          } else if (dy < -SWIPE_DIST) {
            this.move(0, 1)
            this.touch.done = true
          } else if (dy > SWIPE_DIST) {
            this.move(0, -1)
            this.touch.done = true
          }
        }

        e.preventDefault()
      }
    })
    this.refs.board.addEventListener('touchend', e => {
      if (this.active && !this.touch.done) {
        this.refs.board.blur()
      }
    })

    document.addEventListener('keydown', e => this.onKeyDown(e))
    this.refs.focuser.addEventListener('click', e => this.refs.board.focus())

    this.refs.undo.addEventListener('focus', e => {
      e.preventDefault()
      if (e.relatedTarget == this.refs.board) {
        this.refs.board.focus()
      }
    })
    this.refs.undo.addEventListener('click', e => {
      this.undo()
      this.bounce(this.refs.undo)
    })
    this.refs.reset.addEventListener('focus', e => {
      e.preventDefault()
      if (e.relatedTarget == this.refs.board) {
        this.refs.board.focus()
      }
    })
    this.refs.reset.addEventListener('click', e => {
      this.reset()
      this.bounce(this.refs.reset)
    })
    this.refs.link.addEventListener('focus', e => {
      e.preventDefault()
      if (e.relatedTarget == this.refs.board) {
        this.refs.board.focus()
      }
    })
    this.refs.link.addEventListener('click', e => {
      this.copyLinkToClipboard()
      this.bounce(this.refs.link)
    })

    this.refs.autoSolve.addEventListener('change', e => this.updateDisplay())
    this.refs.solveButton.addEventListener('click', e => this.solve())

    this.refs.importInput.addEventListener('focus', e => this.refs.importInput.select())
    this.refs.importButton.addEventListener('click', e => this.import())

    this.history = []
  }

  update () {
    this.refs.name.textContent = this.props.data.name

    this.refs.optimalMoves.textContent = `${this.props.data.optimalMoves}`

    this.refs.board.style.width = `${this.props.data.width * this.props.scale}px`
    this.refs.board.style.height = `${this.props.data.height * this.props.scale}px`

    this.refs.board.innerHTML = ''

    for (let x = 0; x < this.props.data.width; ++x) {
      for (let y = 0; y < this.props.data.height; ++y) {
        let tile = this.tile(x, y)
        if (tile !== ' ') {
          let div = document.createElement('div')

          div.classList.add('tile')
          div.style.width = `${this.props.scale}px`
          div.style.height = `${this.props.scale}px`
          div.style.left = `${x * this.props.scale}px`
          div.style.bottom = `${y * this.props.scale}px`

          if (tile === 'r') {
            div.classList.add('goal')
            div.classList.add('red')
          }
          if (tile === 'b') {
            div.classList.add('goal')
            div.classList.add('blue')
          }

          this.refs.board.append(div)
        }
      }
    }

    this.actors = []
    for (let dataActor of this.props.data.actors) {
      let actor = new Actor({
        x: dataActor.x,
        y: dataActor.y,
        color: dataActor.color,
        scale: this.props.scale,
        height: this.props.data.height,
      })
      this.actors.push(actor)
      this.refs.board.appendChild(actor)
    }

    if (!this.props.controls) {
      this.refs.controls.classList.add('hidden')
    }

    this.refs.importInput.value = JSON.stringify(this.props.data)
  }

  tile (x, y) {
    if (x < 0 || x >= this.props.data.width || y < 0 || y >= this.props.data.height) {
      return null
    } else {
      return this.props.data.tiles[this.props.data.height - y - 1][x]
    }
  }

  activate () {
    this.active = true
    this.classList.add('active')
  }

  deactivate () {
    this.active = false
    this.classList.remove('active')
  }

  onKeyDown (e) {
    if (!this.active) {
      return
    }

    switch (e.code) {
      case 'ArrowRight':
      case 'KeyD':
        this.move(1, 0)
        e.preventDefault()
        break
      case 'ArrowUp':
      case 'KeyW':
        this.move(0, 1)
        e.preventDefault()
        break
      case 'ArrowLeft':
      case 'KeyA':
        this.move(-1, 0)
        e.preventDefault()
        break
      case 'ArrowDown':
      case 'KeyS':
        this.move(0, -1)
        e.preventDefault()
        break
      case 'Space':
      case 'KeyZ':
        if (e.shiftKey) {
          this.reset()
          this.bounce(this.refs.reset)
        } else {
          this.undo()
          this.bounce(this.refs.undo)
        }
        e.preventDefault()
        break
      case 'Escape':
        this.refs.board.blur()
        e.preventDefault()
        break
      case 'Tab':
        if (e.shiftKey) {
          this.refs.board.blur()
          this.refs.link.focus()
          e.preventDefault()
        }
        break
      default:
        break
    }
  }

  move (x, y) {
    let nextPos = []
    for (let actor of this.actors) {
      let nx = actor.props.x
      let ny = actor.props.y
      switch (actor.props.color) {
        case 'red':
          nx += x
          ny += y
          break
        case 'blue':
          nx += -x
          ny += -y
          break
        default:
          throw new Error('Invalid color')
      }

      let tile = this.tile(nx, ny)
      if (tile === ' ' || tile == null) {
        nx = actor.props.x
        ny = actor.props.y
      }

      nextPos.push({
        x: nx,
        y: ny,
      })
    }

    let finished = false
    while (!finished) {
      finished = true
      for (let i = 0; i < nextPos.length; ++i) {
        for (let j = i + 1; j < nextPos.length; ++j) {
          if (nextPos[i].x === nextPos[j].x && nextPos[i].y === nextPos[j].y) {
            nextPos[i] = {
              x: this.actors[i].props.x,
              y: this.actors[i].props.y,
            }
            nextPos[j] = {
              x: this.actors[j].props.x,
              y: this.actors[j].props.y,
            }
            finished = false
          }
        }
      }
    }

    let anyChanged = false
    for (let i = 0; i < nextPos.length; ++i) {
      let actor = this.actors[i]
      if (actor.props.x != nextPos[i].x || actor.props.y != nextPos[i].y) {
        anyChanged = true
      }

      actor.props = {
        ...actor.props,
        x: nextPos[i].x,
        y: nextPos[i].y,
      }
    }

    if (anyChanged) {
      this.history.push(nextPos)
      this.updateDisplay()
    }
  }

  undo () {
    this.history.pop()

    if (this.history.length != 0) {
      let positions = this.history[this.history.length - 1]
      for (let i = 0; i < this.actors.length; ++i) {
        let actor = this.actors[i]
        actor.props = {
          ...actor.props,
          x: positions[i].x,
          y: positions[i].y,
        }
      }
    } else {
      for (let i = 0; i < this.actors.length; ++i) {
        let actor = this.actors[i]
        actor.props = {
          ...actor.props,
          x: this.props.data.actors[i].x,
          y: this.props.data.actors[i].y,
        }
      }
    }

    this.updateDisplay()
  }

  bounce (element) {
    if (element.classList.contains('one')) {
      element.classList.remove('one')
      element.classList.add('two')
    } else {
      element.classList.remove('two')
      element.classList.add('one')
    }
  }

  reset () {
    if (this.history.length < 20) {
      let interval = setInterval(() => {
        if (this.history.length == 0) {
          clearInterval(interval)
        } else {
          this.undo()
        }
      }, 100)
    } else {
      this.history = []
      this.undo()
    }
  }

  isSolved () {
    for (let x = 0; x < this.props.data.width; ++x) {
      for (let y = 0; y < this.props.data.height; ++y) {
        let tile = this.tile(x, y)
        if (tile == 'r' || tile == 'b') {
          let met = false
          for (let actor of this.actors) {
            if (actor.props.x == x && actor.props.y == y) {
              if (tile == 'r' && actor.props.color == 'red') {
                met = true
                break
              } else if (tile == 'b' && actor.props.color == 'blue') {
                met = true
                break
              }
            }
          }
          if (!met) {
            return false
          }
        }
      }
    }

    return true
  }

  updateDisplay () {
    if (this.isSolved()) {
      this.classList.add('solved')
      this.classList.add('was-solved')
      if (this.history.length == this.props.data.optimalMoves) {
        this.classList.add('was-optimal')
      }
    } else {
      this.classList.remove('solved')
    }

    this.refs.moves.textContent = `${this.history.length}`

    if (this.refs.autoSolve.checked) {
      this.solve()
    }
  }

  solve () {
    let puzzle = ''
    for (let row of this.props.data.tiles) {
      puzzle += row + '\n'
    }
    puzzle += '\n'
    for (let actor of this.actors) {
      puzzle += `${actor.props.color == 'red' ? 'R' : 'B'} ${actor.props.x} ${actor.props.y}\n`
    }

    let start = performance.now()
    let solution = wasm_bindgen.solve(puzzle)
    let end = performance.now()
    this.refs.solveTime.textContent = `${((end - start) / 1000).toFixed(3)}s`

    let solutionHTML = ''

    solutionHTML += '<table>'
    for (let [index, move] of solution.entries()) {
      let emoji = '?'
      let direction = '???'
      switch (move) {
        case 0:
          direction = 'Right'
          emoji = '➡️'
          break
        case 1:
          direction = 'Up'
          emoji = '⬆️'
          break
        case 2:
          direction = 'Left'
          emoji = '⬅️'
          break
        case 3:
          direction = 'Down'
          emoji = '⬇️'
          break
      }
      solutionHTML += `<tr><td>${index + 1}</td><td>${direction}</td><td>${emoji}</td></tr>`
    }
    solutionHTML += '</table>'
    this.refs.solution.innerHTML = solutionHTML
  }

  import () {
    this.history = []

    this.classList.remove('solved')
    this.classList.remove('was-solved')
    this.classList.remove('was-optimal')

    let source = this.refs.importInput.value
    try {
      if (source.startsWith(PLAYGROUND_URL)) {
        let base64 = source.match(/(\?|&)data=(?<base64>[a-zA-Z0-9+\/=]*)(&|$)/).groups.base64
        source = atob(base64)
      }

      this.props = {
        ...this.props,
        data: JSON.parse(source),
      }

      this.refs.importInput.classList.remove('error')
      this.updateDisplay()
    } catch (e) {
      this.refs.importInput.classList.add('error')
      console.log(e)
    }
  }

  copyLinkToClipboard () {
    let json = JSON.stringify(this.props.data)
    navigator.clipboard.writeText(`${PLAYGROUND_URL}?data=${btoa(json)}`)
  }
}
window.customElements.define('anima-puzzle', Puzzle)

</script>
<template id="anima-puzzle-template">
    <div class="spacer"></div>
    <div class="board-container">
        <h3 data-ref="name"></h3>
        <div class="controls">
            <div class="left">
                <button data-ref="undo">
                    <img src="data:image/svg+xml,%3Csvg width='24px' height='24px' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7.18,4,8.6,5.44,6.06,8h9.71a6,6,0,0,1,0,12h-2V18h2a4,4,0,0,0,0-8H6.06L8.6,12.51,7.18,13.92,2.23,9Z' /%3E%3C/svg%3E%0A">
                </button>
                <button data-ref="reset">
                    <img src="data:image/svg+xml,%3Csvg width='24px' height='24px' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' stroke='%23000' stroke-width='2' d='M20,8 C18.5974037,5.04031171 15.536972,3 12,3 C7.02943725,3 3,7.02943725 3,12 C3,16.9705627 7.02943725,21 12,21 L12,21 C16.9705627,21 21,16.9705627 21,12 M21,3 L21,9 L15,9'/%3E%3C/svg%3E%0A">
                </button>
            </div>
            <div class="right">
                <button data-ref="link">
                    <img src="data:image/svg+xml,%3Csvg width='24px' height='24px' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='none' stroke='%23000' stroke-width='2' d='M16.1251884,2.42026615 C16.9095797,1.63587482 18.1818354,1.63638083 18.9643331,2.41887857 L21.5811214,5.03566688 C22.3647464,5.81929188 22.3723943,7.08215115 21.5797338,7.87481161 L17.8748116,11.5797338 C17.0904203,12.3641252 15.8181646,12.3636192 15.0356669,11.5811214 L12.4188786,8.96433312 C11.6352536,8.18070812 11.6276057,6.91784885 12.4202662,6.12518839 L16.1251884,2.42026615 Z M6.12518839,12.4202662 C6.90957973,11.6358748 8.18183538,11.6363808 8.96433312,12.4188786 L11.5811214,15.0356669 C12.3647464,15.8192919 12.3723943,17.0821512 11.5797338,17.8748116 L7.87481161,21.5797338 C7.09042027,22.3641252 5.81816462,22.3636192 5.03566688,21.5811214 L2.41887857,18.9643331 C1.63525357,18.1807081 1.6276057,16.9178488 2.42026615,16.1251884 L6.12518839,12.4202662 Z M7,17 L17,7'/%3E%3C/svg%3E%0A">
                </button>
            </div>
        </div>
        <div data-ref="board" tabindex="0"></div>
        <span data-ref="focuser">
            Click to play
        </span>
        <div>
            <span data-ref="moves">0</span><span class="optimal-threshold"> / <span data-ref="optimalMoves">0</span></span> moves
        </div>
    </div>
    <div data-ref="controls">
        <div class="import">
            <input type="text" data-ref="importInput">
            <button data-ref="importButton">Import</button>
        </div>
        <div data-ref="solution">
            <em>Solve to find a solution</em>
        </div>
        <div class="solve">
            <input type="checkbox" data-ref="autoSolve"/>Auto
            <button data-ref="solveButton">Solve</button>
            <span data-ref="solveTime">0.000s</span>
        </div>
    </div>
    <div class="spacer"></div>
    <style>
        :host {
            display: flex;
            align-items: stretch;
            margin: 0.5rem auto;
            overflow-x: auto;
        }
        .spacer {
            flex-grow: 1;
        }
        .board-container {
            text-align: center;
            flex-shrink: 0;
            padding: 0 32px;
        }
        [data-ref="focuser"] {
            display: inline-block;
            position: relative;
            top: -0.3rem;
            padding: 0 0.5rem;
            background-color: #fff;
            border-radius: 0.75rem;
            box-shadow: 0 0 7px rgba(0, 0, 0, 0.5);
            z-index: 1;
            cursor: pointer;
            transform: scale(1);
            transition: transform 0.15s cubic-bezier(.18, .85, .67, 1.53);
        }
        :host(.active) [data-ref="focuser"] {
            transform: scale(0.0);
            transition: transform 0.1s linear;
        }
        .optimal-threshold {
            display: none;
            font-weight: bold;
        }
        :host(.was-solved) .optimal-threshold {
            display: inline;
        }
        :host(.was-solved.was-optimal) .optimal-threshold::after {
            content: " ✔";
            color: #006600;
        }
        .controls {
            display: flex;
            position: relative;
            height: 0;
            flex-direction: row;
            justify-content: space-between;
        }
        .controls .left, .controls .right {
            position: relative;
            top: -10px;
            display: flex;
            flex-direction: column;
        }
        .controls .left {
            left: -34px;
        }
        .controls .right {
            right: -34px;
        }
        @keyframes bounce1 {
            0% {
                transform: scale(1.0);
            }
            30% {
                transform: scale(1.2);
            }
            60% {
                transform: scale(0.8);
            }
            100% {
                transform: scale(1.0);
            }
        }
        @keyframes bounce2 {
            0% {
                transform: scale(1.0);
            }
            30% {
                transform: scale(1.2);
            }
            60% {
                transform: scale(0.8);
            }
            100% {
                transform: scale(1.0);
            }
        }
        [data-ref="reset"], [data-ref="undo"], [data-ref="link"] {
            padding: 6px;
            width: 36px;
            height: 36px;
            border-radius: 18px;
            z-index: 3;
            animation-duration: 0.2s;
        }
        [data-ref="reset"].one, [data-ref="undo"].one, [data-ref="link"].one {
            animation-name: bounce1;
        }
        [data-ref="reset"].two, [data-ref="undo"].two, [data-ref="link"].two {
            animation-name: bounce2;
        }
        [data-ref="board"] {
            background-color: #e8e8e8;
            background-image:
                linear-gradient(135deg, #cccccc 25%, transparent 25%),
                linear-gradient(225deg, #cccccc 25%, transparent 25%),
                linear-gradient(45deg, #cccccc 25%, transparent 25%),
                linear-gradient(315deg, #cccccc 25%, #e8e8e8 25%);
            background-position: 18px 0, 18px 0, 0 0, 0 0;
            background-size: 36px 36px;
            background-repeat: repeat;
            position: relative;
            border-radius: 0.75rem;
            border: 0.5rem solid transparent;
            cursor: pointer;
        }
        :host(.active) [data-ref="board"] {
            cursor: default;
        }
        [data-ref="board"]::before {
            content: " ";
            position: absolute;
            left: -0.5rem;
            right: -0.5rem;
            top: -0.5rem;
            bottom: -0.5rem;
            border-radius: 0.75rem;
            box-shadow: inset 0 0 7px rgba(0, 0, 0, 0.5);
        }
        [data-ref="board"]::after {
            content: " ";
            display: block;
            background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='111.58' height='80.006' version='1.1' viewBox='0 0 111.57827 80.006501' xml:space='preserve' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m110.45 22.652c-1.0152-0.76245-2.4134-0.75457-3.414 0.01636l-29.369 22.42-19.275-43.549c-0.91154-2.0522-4.2759-2.0522-5.1905 0l-19.501 44.05-29.113-22.898c-1.0055-0.78609-2.4116-0.8079-3.4359-0.053335-1.0279 0.76002-1.417 2.1164-0.95579 3.2989l20.226 52.262c0.4188 1.0928 1.4728 1.8085 2.6407 1.8085h65.462c1.177 0 2.2219-0.71275 2.6425-1.8085l20.224-52.262c0.45759-1.1825 0.0739-2.5243-0.94124-3.2843z' fill='%23ffd82b'/%3E%3C/svg%3E%0A");
            background-position: center center;
            background-repeat: no-repeat;
            position: absolute;
            left: 50%;
            top: 50%;
            width: 120px;
            height: 100px;
            opacity: 0.8;
            filter: drop-shadow(0 0 1rem rgba(0, 0, 0, 0.5));
            transform-origin: center;
            transform: translate(-50%, -50%) scale(0.0);
            transition: transform 0.1s linear;
            z-index: 3;
        }
        :host(.solved) [data-ref="board"]::after {
            transform: translate(-50%, -50%) scale(1.0);
            transition: transform 0.25s cubic-bezier(.18, .85, .67, 1.53);
        }
        .tile {
            position: absolute;
        }
        .tile::before {
            content: " ";
            display: block;
            position: absolute;
            width: 96%;
            height: 96%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border-radius: 0.75rem;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .tile::after {
            content: " ";
            display: block;
            position: absolute;
            width: 96%;
            height: 96%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border-radius: 0.75rem;
            background-color: #fff;
            z-index: 1;
        }
        .tile.goal::after {
            background-image:
                linear-gradient(135deg, #fff 40%, transparent 40%),
                linear-gradient(225deg, #fff 40%, transparent 40%),
                linear-gradient(45deg, #fff 40%, transparent 40%),
                linear-gradient(315deg, #fff 40%, transparent 40%);
        }
        .tile.goal.red::after {
            background-color: #ff0046;
        }
        .tile.goal.blue::after {
            background-color: #0989B2;
        }
        button, input {
            padding: 0.25rem 0.5rem;
            background-color: #fff;
            border: 0;
            border-radius: 0.75rem;
            box-shadow: 0 0 7px rgba(0, 0, 0, 0.5);
            font-family: inherit;
            font-size: inherit;
            margin: 0.25rem;
        }
        button {
            cursor: pointer;
        }
        button:hover {
            background-color: #e0e0e0;
        }
        button:active {
            background-color: #ccc;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        }
        input[type="text"] {
            width: 0;
            flex-grow: 1;
        }
        [data-ref="controls"] {
            text-align: center;
            display: flex;
            flex-direction: column;
            margin-left: 0.5rem;
            margin-top: 1rem;
        }
        [data-ref="controls"].hidden {
            display: none;
        }
        .import, .solve {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0.5rem 0;
        }
        [data-ref="importInput"].error {
            background: #ffb8cb;
        }
        [data-ref="solution"] {
            min-width: 200px;
            height: 0;
            flex-grow: 1;
            text-align: center;
            overflow-y: auto;
        }
        [data-ref="solution"] table {
            margin: 0 auto;
            font-family: monospace;
            font-weight: bold;
        }
        [data-ref="solution"] td {
            padding: 0 0.5rem;
            text-align: left;
        }
        [data-ref="solution"] td:first-child {
            text-align: right;
        }
        [data-ref="solveButton"] {
            margin: 0 0.75rem;
        }
        [data-ref="solveTime"] {
            flex-grow: 1;
        }
    </style>
</template>
<template id="anima-actor-template">
    <style>
        :host {
            display: block;
            position: absolute;
            transition: transform 0.15s;
            z-index: 2;
        }
        .color {
            display: block;
            position: absolute;
            overflow: hidden;
            width: 81%;
            height: 81%;
            border-radius: 0.4rem;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        .color::after {
            content: " ";
            position: absolute;
            width: 100%;
            height: 100%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        :host(.red) .color::after {
            background-image:
                linear-gradient(135deg, #ff0046 30%, transparent 30%),
                linear-gradient(225deg, #ff0046 30%, transparent 30%),
                linear-gradient(45deg, #ff0046 30%, transparent 30%),
                linear-gradient(315deg, #ff0046 30%, transparent 30%);
        }
        :host(.blue) .color::after {
            background-image:
                linear-gradient(135deg, #0989B2 30%, transparent 30%),
                linear-gradient(225deg, #0989B2 30%, transparent 30%),
                linear-gradient(45deg, #0989B2 30%, transparent 30%),
                linear-gradient(315deg, #0989B2 30%, transparent 30%);
        }
    </style>
    <div class="color"></div>
</template>










<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="false"
    data-dynamic="false"
>
    {
    "name": "U-Turn",
    "width": 3,
    "height": 3,
    "tiles": [
        "r .",
        ". .",
        "..."
    ],
    "actors": [
        {
            "color": "red",
            "x": 2,
            "y": 2
        }
    ],
    "optimalMoves": 6
}
</script>










<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="false"
    data-dynamic="false"
>
    {
    "name": "Single File",
    "width": 5,
    "height": 3,
    "tiles": [
        ".. rr",
        ".. rr",
        " ... "
    ],
    "actors": [
        {
            "color": "red",
            "x": 0,
            "y": 1
        },
        {
            "color": "red",
            "x": 1,
            "y": 1
        },
        {
            "color": "red",
            "x": 0,
            "y": 2
        },
        {
            "color": "red",
            "x": 1,
            "y": 2
        }
    ],
    "optimalMoves": 16
}
</script>
<p>These two are pretty easy, but you might have noticed some implicit rules that make solving these
puzzles nontrivial:</p>
<ul>
<li>If an actor tries to move into an impassable tile, they do not move.</li>
<li>If an actor would overlap another actor, they do not move.</li>
</ul>
<p>These side-effects make it very difficult (impossible?) to predict how the system will behave after
even a move or two, which is a hallmark of problems with high NP-complexity. We'll add one more
twist to make it a little more interesting:</p>










<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="false"
    data-dynamic="false"
>
    {
    "name": "Gimbal Lock",
    "width": 7,
    "height": 3,
    "tiles": [
        "... ...",
        ". r . .",
        "... ..b"
    ],
    "actors": [
        {
            "color": "red",
            "x": 0,
            "y": 2
        },
        {
            "color": "blue",
            "x": 6,
            "y": 2
        }
    ],
    "optimalMoves": 6
}
</script>
<p>Unlike red actors, blue actors move in the opposite direction you choose. If you choose left, blue
actors will move right and vice-versa. This leads to one final implicit rule:</p>










<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="false"
    data-dynamic="false"
>
    {
    "name": "Deadlock",
    "width": 3,
    "height": 3,
    "tiles": [
        " . ",
        "br.",
        " b "
    ],
    "actors": [
        {
            "color": "red",
            "x": 1,
            "y": 1
        },
        {
            "color": "blue",
            "x": 2,
            "y": 1
        },
        {
            "color": "blue",
            "x": 1,
            "y": 2
        }
    ],
    "optimalMoves": 6
}
</script>
<p>When they're right next to each other, red and blue actors can pass through each other to exchange
positions. However, if they're separated by a single space, they'll try to move onto the same space
and block each other from moving at all. This added complexity can make puzzles much more difficult
to solve.</p>
<p>Before diving in, I'd definitely recommend trying out some more puzzles to get a better feel for
some high-level techniques and to get better acquainted with the game. Don't worry about solving
all of these, they can get very hard. Just work with them until you feel competent and confident.</p>
<div class="center"><div><h2 id="practice-puzzles"><a href="/blog/anima-puzzles/"><strong>Practice Puzzles</strong></a></h2>
</div></div>
<p>This is where we start writing our solver. You can follow along using the <code>start</code> tag on the
<a href="https://github.com/djkoloski/anima_solver">GitHub repo</a>, which will start you with all of the
boilerplate:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>git clone --branch start https://github.com/djkoloski/anima_solver</span><span>
</span></code></pre>
<h2 id="a-basic-solver">A basic solver</h2>
<p>Our strategy for a basic solver will be to explore, one move at a time, out from
the initial state until we find a solution. I'll do this with a basic
breadth-first search augmented with parent tracking:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">solve</span><span>(initial_state: State, data: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>Data) -&gt; </span><span style="color:#0086b3;">Option</span><span>&lt;</span><span style="color:#0086b3;">Vec</span><span>&lt;Direction&gt;&gt; {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> parents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span>::new();</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> queue </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>VecDeque::new();</span><span>
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Add transitions from initial state</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>(action, transition) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> initial_state.</span><span style="color:#62a35c;">transitions</span><span>(data) {</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span> transition {</span><span>
</span><span>            Transition::Indeterminate(state) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span>{</span><span>
</span><span>                parents.</span><span style="color:#62a35c;">push</span><span>((</span><span style="color:#0086b3;">0</span><span>, action));</span><span>
</span><span>                queue.</span><span style="color:#62a35c;">push_back</span><span>(state);</span><span>
</span><span>            }</span><span>
</span><span>            Transition::Success </span><span style="font-weight:bold;color:#a71d5d;">=&gt; return </span><span style="color:#0086b3;">Some</span><span>(vec![action]),</span><span>
</span><span>        }</span><span>
</span><span>    }</span><span>
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Pop states in order</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> index </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span>;</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">while let </span><span style="color:#0086b3;">Some</span><span>(parent_node) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> queue.</span><span style="color:#62a35c;">pop_front</span><span>() {</span><span>
</span><span>        index </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span>;</span><span>
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>(action, transition) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> parent_node.</span><span style="color:#62a35c;">transitions</span><span>(data) {</span><span>
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">match</span><span> transition {</span><span>
</span><span>                Transition::Indeterminate(state) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span>{</span><span>
</span><span>                    parents.</span><span style="color:#62a35c;">push</span><span>((index, action));</span><span>
</span><span>                    queue.</span><span style="color:#62a35c;">push_back</span><span>(state);</span><span>
</span><span>                }</span><span>
</span><span>                Transition::Success </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span>{</span><span>
</span><span>                    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> result_actions </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>vec![action];</span><span>
</span><span>                    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> current_index </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> index;</span><span>
</span><span>                    </span><span style="font-weight:bold;color:#a71d5d;">while</span><span> current_index </span><span style="font-weight:bold;color:#a71d5d;">!= </span><span style="color:#0086b3;">0 </span><span>{</span><span>
</span><span>                        </span><span style="font-weight:bold;color:#a71d5d;">let </span><span>(next_index, action) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> parents.</span><span style="color:#62a35c;">swap_remove</span><span>(current_index </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">1</span><span>);</span><span>
</span><span>                        result_actions.</span><span style="color:#62a35c;">push</span><span>(action);</span><span>
</span><span>                        current_index </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> next_index;</span><span>
</span><span>                    }</span><span>
</span><span>                    result_actions.</span><span style="color:#62a35c;">reverse</span><span>();</span><span>
</span><span>                    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">Some</span><span>(result_actions);</span><span>
</span><span>                }</span><span>
</span><span>            }</span><span>
</span><span>        }</span><span>
</span><span>    }</span><span>
</span><span>
</span><span>    </span><span style="color:#0086b3;">None</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>There's a lot of boilerplate omitted, so here's what's relevant:</p>
<ul>
<li>We have <code>State</code> and <code>Data</code> structs where <code>State</code> is all the information that can change and
<code>Data</code> is all the information that is static. <code>State</code> is the positions of the actors, and <code>Data</code>
is the layout of the board and goal positions. These are separated out to minimize how much memory
is being used by <code>queue</code>.</li>
<li>The <code>transitions()</code> method operates on a <code>State</code>, takes some <code>Data</code>, and returns the new states
we reach by performing every possible move. An <code>Indeterminate</code> transition means that the state you
reach is not solved, and a <code>Success</code> transition means that it is.</li>
</ul>
<p><code>parents</code> here is a list of <code>(usize, Direction)</code> that tracks what state it came from and what
direction was moved to transition. When we get a successful transition, we crawl back through the
<code>parents</code> vector to reassemble the solution and return it. Let's try it out!</p>
<p>We're going to use a nice and simple one to test:</p>










<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="false"
    data-dynamic="false"
>
    {
    "name": "Line Dance",
    "width": 3,
    "height": 1,
    "tiles": [
        "..r"
    ],
    "actors": [
        {
            "color": "red",
            "x": 0,
            "y": 0
        }
    ],
    "optimalMoves": 2
}
</script>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span> puzzles/line_dance.txt</span><span>
</span><span>puzzles/line_dance.txt:</span><span>
</span><span>Parse: 0.000201900s</span><span>
</span><span>Solve: 0.000017600s</span><span>
</span><span>Found solution of length 2:</span><span>
</span><span>Right, Right</span><span>
</span></code></pre>
<p>Cool, it found it! And that looks right too, let's see how fast it is in release mode:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run --release</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span> puzzles/line_dance.txt</span><span>
</span><span>puzzles/line_dance.txt:</span><span>
</span><span>Parse: 0.000122700s</span><span>
</span><span>Solve: 0.000009100s</span><span>
</span><span>Found solution of length 2:</span><span>
</span><span>Right, Right</span><span>
</span></code></pre>
<p>Roughly twice as fast, great! We're going to be running exclusively in release mode from here on
out. Now let's step it up a little bit and try a harder puzzle:</p>










<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="false"
    data-dynamic="false"
>
    {
    "name": "U-Turn",
    "width": 3,
    "height": 3,
    "tiles": [
        "r .",
        ". .",
        "..."
    ],
    "actors": [
        {
            "color": "red",
            "x": 2,
            "y": 2
        }
    ],
    "optimalMoves": 6
}
</script>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run --release</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span> puzzles/u_turn.txt</span><span>
</span><span>puzzles/u_turn.txt:</span><span>
</span><span>Parse: 0.005942000s</span><span>
</span><span>Solve: 0.001093200s</span><span>
</span><span>Found solution of length 6:</span><span>
</span><span>Down, Down, Left, Left, Up, Up</span><span>
</span></code></pre>
<p>Awesome, it got that one too! One more, this one's really more of the same:</p>










<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="false"
    data-dynamic="false"
>
    {
    "name": "Spiral",
    "width": 5,
    "height": 5,
    "tiles": [
        ".....",
        ".   .",
        "... .",
        "    .",
        "r...."
    ],
    "actors": [
        {
            "color": "red",
            "x": 2,
            "y": 2
        }
    ],
    "optimalMoves": 16
}
</script>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run --release</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span> puzzles/spiral.txt</span><span>
</span><span>...</span><span>
</span></code></pre>
<p>Uh oh, this one doesn't seem to be going anywhere fast. And if you don't kill it soon, you might run
out of memory too! Looking at the timings explains why:</p>
<pre data-lang="txt" style="background-color:#ffffff;color:#323232;" class="language-txt "><code class="language-txt" data-lang="txt"><span>puzzles/line_dance.txt</span><span>
</span><span>Solve: 0.000009100s</span><span>
</span><span>Found solution of length 2:</span><span>
</span><span>
</span><span>puzzles/u_turn.txt</span><span>
</span><span>Solve: 0.001093200s</span><span>
</span><span>Found solution of length 6:</span><span>
</span></code></pre>
<p>By adding just four moves to the solution length, our runtime went up by a factor of <strong>120x</strong>! Let's
take a peek at how many states we're exploring:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>println!(</span><span style="color:#183691;">&quot;Explored </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> states&quot;</span><span>, parents.</span><span style="color:#62a35c;">len</span><span>());</span><span>
</span></code></pre>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run --release</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span> puzzles/line_dance.txt</span><span>
</span><span>Explored 3 states</span><span>
</span><span>
</span><span>$ cargo run --release</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span> puzzles/u_turn.txt</span><span>
</span><span>Explored 5364 states</span><span>
</span></code></pre>
<p>Yikes, there's our problem. And it makes sense, every state we explore leads to four more states so
we should expect that a solution of length <code>n</code> will explore at least <code>(4^n - 1) / 3</code> states. For a
6-move solution, that comes out to between 1365 and 5461 states, so we're right in that range. What
does that mean for our currently-unsolvable puzzle? It takes 16 moves to solve it, so we should
expect to explore between 1431655765 and 5726623061 states.</p>
<p>Uh oh.</p>
<p>Now it's time to start iterating on our solver and improving it. We will measure progress by
measuring how long it takes to solve existing puzzles, then creating new and more difficult puzzles
as we go along. Our goal will be to quickly solve all puzzles that we can create.</p>
<h2 id="state-tracking">State tracking</h2>
<p>First, we should observe that even though we explored 5364 states for <em>U-Turn</em>, there are
functionally only seven unique states: one for each of the tiles the actor could be on. So we must
be exploring the same state multiple times. We can avoid this by storing our explored states in a
hash set and only exploring its children if it's not already been visited:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> states </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>HashSet::new();</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">while let </span><span style="color:#0086b3;">Some</span><span>(parent_node) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> queue.</span><span style="color:#62a35c;">pop_front</span><span>() {</span><span>
</span><span>    index </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span>;</span><span>
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if !</span><span>states.</span><span style="color:#62a35c;">contains</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>parent_node) {</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>
</span><span>        states.</span><span style="color:#62a35c;">insert</span><span>(parent_node);</span><span>
</span><span>    }</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Let's see how this affects our cases so far:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run --release</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span> puzzles/u_turn.txt</span><span>
</span><span>Explored 20 states</span><span>
</span><span>Solve: 0.000895100s</span><span>
</span><span>Found solution of length 6:   </span><span>
</span><span>Down, Down, Left, Left, Up, Up</span><span>
</span></code></pre>
<p>That looks much better! Maybe we can solve our new puzzle now?</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run --release</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span> puzzles/spiral.txt</span><span>
</span><span>Explored 51 states</span><span>
</span><span>puzzles/spiral.txt:</span><span>
</span><span>Parse: 0.000212300s</span><span>
</span><span>Solve: 0.001049000s</span><span>
</span><span>Found solution of length 16:</span><span>
</span><span>Left, Left, Up, Up, Right, Right, Right, Right, Down, Down, Down, Down, Left, Left, Left, Left</span><span>
</span></code></pre>
<p>That's much better, bringing our explored states down from over a billion to just 51. This
optimization alone brings all our sample puzzles into the realm of solvability! Now we can start
benchmarking our solver more comprehensively. Let's pick a few representatives from the
<a href="/blog/">sample puzzles set</a> to bench:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo bench</span><span>
</span><span>solve_square_dance      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>16.658 ms 16.888 ms 17.125 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>solve_fractal           time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>44.606 ms 45.193 ms 45.806 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>solve_antiparticle      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>1.8001 s 1.8308 s 1.8640 s</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span></code></pre>
<h2 id="entropy-reduction">Entropy reduction</h2>
<p>One easy optimization we can make is to reduce the entropy of our states. Right now our puzzle state
looks like this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">enum </span><span>Color {</span><span>
</span><span>    Red,</span><span>
</span><span>    Blue,</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>Actor {</span><span>
</span><span>    position: Vec2,</span><span>
</span><span>    color: Color,</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>State {</span><span>
</span><span>    actors: </span><span style="color:#0086b3;">Vec</span><span>&lt;Actor&gt;,</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>So imagine a board with a few red actors on it. Let's say four, labeled A, B, C, and D:</p>
<div class="center"><div><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>A</td><td>_</td><td>B</td></tr>
<tr><td>_</td><td>_</td><td>_</td></tr>
<tr><td>C</td><td>_</td><td>D</td></tr>
</tbody></table>
</div></div>
<p>With these four actors, there's actually <code>4!</code> ways we could represent the state since there are <code>4!</code>
permutations of the actors in the vector. We can fix this by sorting our <code>actors</code> array. This will
reorder any permutation of the actors into one canonical ordering. We can do this pretty easily when
we transition our states:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">transition</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self, data: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>Data, direction: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>Direction) -&gt; State {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> result </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>self.</span><span style="color:#62a35c;">clone</span><span>();</span><span>
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>
</span><span>    result.actors.</span><span style="color:#62a35c;">sort</span><span>();</span><span>
</span><span>    result</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>A good way to think of this is as removing any unnecessary entropy in the state. Let's see how that
affects our benchmarks:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo bench</span><span>
</span><span>
</span><span>solve_square_dance      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>4.4875 ms 4.5667 ms 4.6525 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-73.527% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>72.960% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>72.308%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_fractal           time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>19.518 ms 19.647 ms 19.776 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-57.178% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>56.527% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>55.885%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_antiparticle      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>187.49 ms 190.53 ms 193.91 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-89.835% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>89.593% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>89.343%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span></code></pre>
<p>Let's see how the number of states explored (and branching factor) changed with that:</p>
<table><thead><tr><th>Puzzle</th><th align="right">Solution Length</th><th align="right">Before (BF)</th><th align="right">After (BF)</th><th align="right">Change</th></tr></thead><tbody>
<tr><td>Square Dance</td><td align="right">12</td><td align="right">37268 (2.292)</td><td align="right">11401 (2.061)</td><td align="right">-61.408%</td></tr>
<tr><td>Fractal</td><td align="right">13</td><td align="right">86277 (2.294)</td><td align="right">46253 (2.179)</td><td align="right">-46.390%</td></tr>
<tr><td>Antiparticle</td><td align="right">22</td><td align="right">2514936 (1.888)</td><td align="right">315100 (1.708)</td><td align="right">-87.471%</td></tr>
</tbody></table>
<p>Getting big performance improvements from small changes like this is what we're aiming to do most of
the time. The important thing here is that by reducing our state entropy, we reduced our branching
factor by a little bit. That small change amplifies quickly in exponential algorithms, so even a
very small decrease can lead to huge improvements.</p>
<h2 id="a-search">A* search</h2>
<p>With that in mind, one easy way we can decrease our branching factor even more is by using a more
sophisticated searching algorithm. A* is a very common augmentation to breadth-first search that
prioritizes exploring more promising nodes first. In practice, this means that we have to define a
<em>heuristic function</em> that estimates the minimum number of moves to completion. We want our heuristic
function to estimate the remaining distance as closely as possible, but never overestimate. It's
okay to underestimate. With this estimate of the number of moves remaining, we prioritize exploring
states that have the minimum estimated solution size (moves so far + remaining moves). This can help
us avoid exploring states that are clearly dead ends and prioritize states that look promising.</p>
<p>The main difficulty with implementing A* is determining a good heuristic function. A good heuristic
function should be <em>easy to compute</em> and return an estimate that is <em>as high as possible</em> without
overestimating. This is a tradeoff that we actively have to be conscious of. In most cases, it will
be a net positive. Let's think about what heuristics we can calculate for our puzzle:</p>










<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="false"
    data-dynamic="false"
>
    {
    "name": "Square Dance",
    "width": 5,
    "height": 5,
    "tiles": [
        " ....",
        ".r.r.",
        ".. ..",
        ".r.r.",
        ".... "
    ],
    "actors": [
        {
            "color": "red",
            "x": 2,
            "y": 1
        },
        {
            "color": "red",
            "x": 1,
            "y": 2
        },
        {
            "color": "red",
            "x": 3,
            "y": 2
        },
        {
            "color": "red",
            "x": 2,
            "y": 3
        }
    ],
    "optimalMoves": 12
}
</script>
<p>In order to complete the puzzle, each goal needs one actor of its color on top of it. Since all the
actors move at the same time, we can use a straightforward <em>maxmin</em>: Find the nearest actor to each
goal and calculate the distance between them, then take the maximum value of all goal distances. The
logical way to think about this is that we're calculating the minimum number of moves necessary to
get any actor of our choice to any given goal. This is an extremely rough estimate, but it will work
for us. If we wanted, we could calculate the
<a href="https://en.wikipedia.org/wiki/Linear_bottleneck_assignment_problem">assignment bottleneck</a> instead,
but that could take a lot of time and negatively impact our performance. Also UPS lost my book from
SIAM.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">heuristic</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self, data: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>Data) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">usize </span><span>{</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> max_distance </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span>;</span><span>
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> goal </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> data.goals.</span><span style="color:#62a35c;">iter</span><span>() {</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> min_distance </span><span style="font-weight:bold;color:#a71d5d;">= usize</span><span>::</span><span style="color:#0086b3;">MAX</span><span>;</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> actor </span><span style="font-weight:bold;color:#a71d5d;">in </span><span>self.actors.</span><span style="color:#62a35c;">iter</span><span>().</span><span style="color:#62a35c;">filter</span><span>(|a| a.color </span><span style="font-weight:bold;color:#a71d5d;">==</span><span> goal.color) {</span><span>
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> d </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>(goal.position </span><span style="font-weight:bold;color:#a71d5d;">-</span><span> actor.position).</span><span style="color:#62a35c;">abs</span><span>();</span><span>
</span><span>            min_distance </span><span style="font-weight:bold;color:#a71d5d;">= usize</span><span>::min(min_distance, (d.x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span> d.y) </span><span style="font-weight:bold;color:#a71d5d;">as usize</span><span>);</span><span>
</span><span>        }</span><span>
</span><span>        max_distance </span><span style="font-weight:bold;color:#a71d5d;">= usize</span><span>::max(max_distance, min_distance);</span><span>
</span><span>    }</span><span>
</span><span>
</span><span>    max_distance</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Does what it says on the tin. The more difficult part is adapting our existing <code>solve</code> function to
prioritize states and calculate the heuristic. The first change we'll make is to bundle all of the
information we need when exploring a node into a new structure:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[derive(Eq, PartialEq)]</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Node {</span><span>
</span><span>    state: State,</span><span>
</span><span>    distance: </span><span style="font-weight:bold;color:#a71d5d;">usize</span><span>,</span><span>
</span><span>    estimate: </span><span style="font-weight:bold;color:#a71d5d;">usize</span><span>,</span><span>
</span><span>    index: </span><span style="font-weight:bold;color:#a71d5d;">usize</span><span>,</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This will be what we insert into our queue now. Speaking of which:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> queue </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>BinaryHeap::new();</span><span>
</span></code></pre>
<p>A <code>BinaryHeap</code> is a simple data structure that we can use as a priority queue. We can insert items
and remove the maximum value in <code>log(N)</code> time. All we need to do is define an ordering on our nodes
that gives the most promising nodes (with lowest distance + heuristic) the highest priority:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">impl </span><span>PartialOrd </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Node {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">partial_cmp</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self, other: </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self</span><span>) -&gt; </span><span style="color:#0086b3;">Option</span><span>&lt;Ordering&gt; {</span><span>
</span><span>        </span><span style="color:#0086b3;">Some</span><span>(self.</span><span style="color:#62a35c;">cmp</span><span>(other))</span><span>
</span><span>    }</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Ord </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Node {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">cmp</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self, other: </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self</span><span>) -&gt; Ordering {</span><span>
</span><span>        other.estimate.</span><span style="color:#62a35c;">cmp</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self.estimate)</span><span>
</span><span>    }</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>A little opaque, but this just says that we want to sort in reverse <code>estimate</code> order. Finally, we
need to change our <code>push</code> operation to account for the new fields we need to fill out in <code>Node</code>:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let</span><span> estimate </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> state.</span><span style="color:#62a35c;">heuristic</span><span>(data) </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span>(parent_node.distance </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1</span><span>);</span><span>
</span><span>queue.</span><span style="color:#62a35c;">push</span><span>(Node {</span><span>
</span><span>    state: state,</span><span>
</span><span>    distance: parent_node.distance </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1</span><span>,</span><span>
</span><span>    estimate,</span><span>
</span><span>    index: parents.</span><span style="color:#62a35c;">len</span><span>(),</span><span>
</span><span>});</span><span>
</span></code></pre>
<p>Instead of counting our states as we pop them off, we now need to keep track of which index our
current state is in the <code>parents</code> list. And with that, we're done! We have a fully-functional A*
implementation ready to make our solver go super fast!</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo bench</span><span>
</span><span>
</span><span>solve_square_dance      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>4.4051 ms 4.4276 ms 4.4524 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>+3.7025% +4.6095% +5.4779%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_fractal           time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>7.7314 ms 7.7718 ms 7.8183 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-57.412% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>57.044% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>56.682%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_antiparticle      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>201.26 ms 202.26 ms 203.36 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>+14.570% +15.351% +16.121%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span></code></pre>
<p>Well that's a little disappointing. At least, it is if you only look at the individual benchmarks.
Two went up by around 5-15%, and one went down by over 50%. So while it wasn't a unilateral gain, it
did give us a net benefit overall. And now, if we can improve our heuristic function somehow we can
gain the benefit from that too. Let's take a look at our explored states (and branching factor):</p>
<table><thead><tr><th>Puzzle</th><th align="right">Solution Length</th><th align="right">Before (BF)</th><th align="right">After (BF)</th><th align="right">Change</th></tr></thead><tbody>
<tr><td>Square Dance</td><td align="right">12</td><td align="right">11401 (2.061)</td><td align="right">9737 (2.031)</td><td align="right">-14.595%</td></tr>
<tr><td>Fractal</td><td align="right">13</td><td align="right">46253 (2.179)</td><td align="right">16593 (2.002)</td><td align="right">-64.126%</td></tr>
<tr><td>Antiparticle</td><td align="right">22</td><td align="right">315100 (1.708)</td><td align="right">269211 (1.695)</td><td align="right">-14.563%</td></tr>
</tbody></table>
<p>It's important to remember to benchmark very carefully, since even though our states explored fell
for every puzzle, our total runtime did increase for two of them. Also a very small change in the
branching factor for <em>Fractal</em> resulted in a massive decrease in explored states. The average
runtime has fallen quite nicely.</p>
<h2 id="reducing-allocations">Reducing allocations</h2>
<p>The first rule of high-performance optimization is to reduce your allocations. Let's take a look and
see if there are some places we can do that:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">transitions</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self, data: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>Data) -&gt; </span><span style="color:#0086b3;">Vec</span><span>&lt;(Direction, Transition&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;)&gt; {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Our transitions function is returning a <code>Vec</code> with data allocated on the heap, but we know that
we'll always return four transitions. We can make this return an array instead:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">transitions</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>self, data: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>Data) -&gt; [(Direction, Transition&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;); </span><span style="color:#0086b3;">4</span><span>] {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Let's see what that gets us:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo bench</span><span>
</span><span>
</span><span>solve_square_dance      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>4.4052 ms 4.4415 ms 4.4867 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-7.0971% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>6.1140% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>4.9385%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_fractal           time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>7.6836 ms 7.7682 ms 7.8720 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-8.5312% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>7.0938% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>5.5943%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_antiparticle      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>207.00 ms 207.71 ms 208.44 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-4.9600% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>4.2495% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>3.5907%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span></code></pre>
<p>Some modest gains, let's keep going. Next we can use the <code>arrayvec</code> crate to reduce the number of
allocations in our states. It's essentially an inline-allocated array structure, so we won't
constantly be allocating heap memory as long as we can put an upper bound on the number of actors in
our puzzles. Let's pick eight for some headroom:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>State {</span><span>
</span><span>    actors: ArrayVec&lt;Actor, 8&gt;,</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>How about that:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo bench</span><span>
</span><span>
</span><span>solve_square_dance      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>4.0299 ms 4.0567 ms 4.0854 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-9.7690% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>8.6635% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>7.6778%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_fractal           time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>7.4610 ms 7.5152 ms 7.5743 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-4.6656% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>3.2571% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>1.9086%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_antiparticle      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>187.27 ms 188.29 ms 189.38 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-9.9536% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>9.3494% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>8.7499%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span></code></pre>
<p>Nice! Some more modest gains, but every bit helps. It's finally time to move on to...</p>
<h2 id="profiling">Profiling</h2>
<p>We're out of low-hanging fruit, so let's move on to doing some micro-optimization. There's still
plenty to be gained here though, and we can find it by doing some profiling. Running our benchmarks
in Visual Studio gets us some interesting insights:</p>

<img src="https:&#x2F;&#x2F;david.kolo.ski&#x2F;processed_images&#x2F;44e6965e7b49e13a00.png" />
<p>Here they are typed out:</p>
<table><thead><tr><th>Function</th><th align="right">Total CPU %</th></tr></thead><tbody>
<tr><td><code>anima_solver::puzzle::State::transitions</code></td><td align="right">24.40%</td></tr>
<tr><td><code>hashbrown::map::HashMap::contains_key</code></td><td align="right">20.72%</td></tr>
<tr><td><code>hashbrown::map::HashMap::insert</code></td><td align="right">19.83%</td></tr>
<tr><td><code>alloc::collections::binary_heap::BinaryHeap::pop</code></td><td align="right">15.91%</td></tr>
</tbody></table>
<p>One thing that immediately jumps out is that we're spending almost the same amount of time in
<code>HashMap::contains_key</code> as we do in <code>HashMap::insert</code>. But we don't have any hash maps in our
solver, do we?</p>
<p>Well actually, we do. We're using a <code>HashSet</code> for our visited states, and that's secretly a
<code>HashMap&lt;K, ()&gt;</code> under the hood. Let's take a look at our code:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> states </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>HashSet::new();</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">while let </span><span style="color:#0086b3;">Some</span><span>(parent_node) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> queue.</span><span style="color:#62a35c;">pop</span><span>() {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if !</span><span>states.</span><span style="color:#62a35c;">contains</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>parent_node.state) {</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>(action, transition) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> parent_node.state.</span><span style="color:#62a35c;">transitions</span><span>(data) {</span><span>
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>        }</span><span>
</span><span>        states.</span><span style="color:#62a35c;">insert</span><span>(parent_node.state);</span><span>
</span><span>    }</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>So there's the problem, we're checking to see if the set contains the state, then getting our
transitions, and after that we're inserting the state. We should be able to use an <code>Entry</code> API to
check if the set contains the state and insert it with a single lookup right? Well... <code>HashSet</code>
doesn't have an entry API like <code>HashMap</code> does <a href="https://github.com/rust-lang/rfcs/issues/1490">yet</a>.
Well, I guess we can use a <code>HashMap</code> with a value of <code>()</code> right?</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> states </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>HashMap::new();</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">while let </span><span style="color:#0086b3;">Some</span><span>(parent_node) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> queue.</span><span style="color:#62a35c;">pop</span><span>() {</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if let </span><span>Entry::Vacant(entry) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> states.</span><span style="color:#62a35c;">entry</span><span>(parent_node.state) {</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>(action, transition) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> entry.</span><span style="color:#62a35c;">key</span><span>().</span><span style="color:#62a35c;">transitions</span><span>(data) {</span><span>
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">...</span><span>
</span><span>        }</span><span>
</span><span>        entry.</span><span style="color:#62a35c;">insert</span><span>(());</span><span>
</span><span>    }</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>That should do the trick. Let's see how that changed our runtime:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo bench</span><span>
</span><span>
</span><span>solve_square_dance      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>3.8785 ms 3.9364 ms 3.9998 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>+0.9796% +2.8698% +4.8065%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_fractal           time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>6.7915 ms 6.8446 ms 6.9022 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-2.2994% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>1.2597% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>0.0914%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.03 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_antiparticle      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>172.04 ms 172.76 ms 173.54 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-2.4655% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>1.8303% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>1.1884%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span></code></pre>
<p>Well that's disappointing, there's statistically no change in runtime. I guess the entry API must
have some overhead that's just as expensive as a lookup and insert. If anyone has ideas on why this
didn't change the overall runtime, I'd love to know. But this also shows the importance of
benchmarking every step of the way. Even the most obvious improvements can end up having no effect
on the overall performance, or worse a negative impact.</p>
<h2 id="container-pre-sizing">Container pre-sizing</h2>
<p>We're getting close to the bottom of the barrel. A quick and easy optimization we can do is to
pre-size our containers. This helps us skip any work we might do to resize containers for work loads
under some minimum size. I've picked some relatively arbitrary pre-sizes here:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> states </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>HashMap::with_capacity(</span><span style="color:#0086b3;">4 </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#0086b3;">1024</span><span>);</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> parents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span>::with_capacity(</span><span style="color:#0086b3;">4 </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#0086b3;">1024</span><span>);</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> queue </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>BinaryHeap::with_capacity(</span><span style="color:#0086b3;">1024</span><span>);</span><span>
</span></code></pre>
<p>We should expect these to only impact any puzzles that don't use memory above the pre-sizing
threshold. Do we?</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo bench</span><span>
</span><span>
</span><span>solve_square_dance      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>3.7025 ms 3.7311 ms 3.7652 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-9.7612% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>8.3409% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>6.9754%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_fractal           time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>6.0512 ms 6.1010 ms 6.1584 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-15.633% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>14.231% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>12.778%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_antiparticle      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>177.28 ms 178.40 ms 179.59 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-0.7913% +0.0458% +0.8882%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.92 </span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span></code></pre>
<p>That's exactly what we see. We do get some very nice deltas on our smaller puzzles, but our larger
puzzle benchmark is completely unaffected. Still, it's bringing down our average case and that's
important for us. Finally, we can move on to the last optimization strategy:</p>
<h2 id="inlining">Inlining</h2>
<p>One of the last tools in our performance toolbox is function inlining. The impact of function
inlining varies widely, and we should always be careful to benchmark our code along the way. Let's
see if there are any good candidates for inlining. Ideally, a good function to inline should either
be <em>small</em> or medium-sized and used <em>once or twice</em>. We have a lot of basic little functions in our
vector and direction primitives that we can inline, so those might help a little. Inlining our
especially hot <code>transition</code> function for our puzzle state should also help eliminate some overhead.
Let's see how that impacts our performance:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo bench</span><span>
</span><span>
</span><span>solve_square_dance      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>3.7629 ms 3.8005 ms 3.8413 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-10.293% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>8.6516% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>6.9645%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_fractal           time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>6.7174 ms 6.8059 ms 6.9033 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-10.243% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>8.5148% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>6.7086%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span><span>
</span><span>solve_antiparticle      time:   </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>175.97 ms 176.63 ms 177.38 ms</span><span style="font-weight:bold;color:#a71d5d;">]</span><span>
</span><span>                        change: </span><span style="font-weight:bold;color:#a71d5d;">[</span><span>-6.8481% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>5.9110% </span><span style="font-weight:bold;color:#a71d5d;">-</span><span>5.0767%</span><span style="font-weight:bold;color:#a71d5d;">]</span><span> (p = 0.00 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span>.05)</span><span>
</span></code></pre>
<p>A final solid set of improvements! It's always nice to see. Let's wrap up with some final thoughts.</p>
<h2 id="wrap-up">Wrap up</h2>
<p>We've successfully made a puzzle solver that's capable of solving all of our given inputs and
optimized it using techniques specific to brute-forcing as well as general optimization techniques.
We looked at the performance impacts of various techniques and know what to expect in the future.
Finally, we also learned not to assume that any particular optimization will affect every case
evenly, or even positively.</p>
<p>In the future, the best gains will likely come from improving our heuristic function. For this
relatively simple game, there might not be much of a better heuristic we can calculate. In a more
complex game, we can often leverage the information in the puzzle to make a much better function
though. When writing a solver for Stephen's Sausage Roll, which permitted a more accurate heuristic,
the gains from a heuristic function were much larger.</p>
<p>Finally, you can actually use the solver written here right now! You can turn on the solver for any
page that has a puzzle on it by adding <code>&amp;controls=true</code> to the URL
(<a href="/blog/anima-playground?controls=true">here</a> for example). Here's one with the solver enabled, try
it out! You can also write, import, and share your own puzzles.</p>
<p>Thanks for reading, and happy solving!</p>








<script
    class="anima-data"
    type="application/json"
    data-scale="50"
    data-controls="true"
    data-dynamic="false"
>
    {
    "name": "Box Step",
    "width": 5,
    "height": 3,
    "tiles": [
        ".r.b.",
        ".....",
        ".b.r."
    ],
    "actors": [
        {
            "color": "red",
            "x": 3,
            "y": 2
        },
        {
            "color": "red",
            "x": 1,
            "y": 0
        },
        {
            "color": "blue",
            "x": 1,
            "y": 2
        },
        {
            "color": "blue",
            "x": 3,
            "y": 0
        }
    ],
    "optimalMoves": 15
}
</script>

</div>
<div class="section navigation">
    
        Previous article: <a href="https:&#x2F;&#x2F;david.kolo.ski&#x2F;blog&#x2F;rkyv-is-faster-than&#x2F;">rkyv is faster than {bincode, capnp, cbor, flatbuffers, postcard, prost, serde_json}</a>
    
    
        Next article: <a href="https:&#x2F;&#x2F;david.kolo.ski&#x2F;blog&#x2F;anima-puzzles&#x2F;">Anima Puzzles</a>
    
</div>

    <div class="section footer">
        &copy; 2022 David Koloski
        <a href="/atom.xml"><img width="16" height="16" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 455 455'%3E%3Cpath d='M0 0v455h455V0H0zm141.435 372.387c-7.656 7.59-18.047 12.219-29.614 12.219-11.555 0-21.945-4.646-29.549-12.219C74.681 364.801 70 354.462 70 342.961s4.681-21.875 12.272-29.483c7.621-7.569 17.994-12.237 29.549-12.237 11.567 0 21.958 4.668 29.579 12.254 7.621 7.621 12.272 17.964 12.307 29.466-.035 11.501-4.686 21.822-12.272 29.426zM217.468 385s0-.101-.017-.101c-.066-39.41-15.431-76.597-43.221-104.352-27.786-27.838-64.925-43.256-104.195-43.291v-60.139c57.299.035 109.169 23.327 146.833 61.014 37.651 37.682 60.944 89.565 60.996 146.869h-60.396zm107.24 0c-.105-140.495-114.196-254.774-254.572-254.879V70c86.817.035 165.432 35.359 222.495 92.422C349.659 219.485 384.965 298.165 385 385h-60.292z' fill-rule='evenodd' fill='%23fff'/%3E%3C/svg%3E"></a>
    </div>
</body>
</html>