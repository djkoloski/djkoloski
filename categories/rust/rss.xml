<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>David Koloski</title>
        <link>https://davidkoloski.me</link>
        <description>Software Engineer, Game Designer, Web Developer</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://davidkoloski.me/categories/rust/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Thu, 11 Mar 2021 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>rkyv is faster than {bincode, capnp, cbor, flatbuffers, postcard, prost, serde_json}</title>
                <pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate>
                <link>https://davidkoloski.me/blog/rkyv-is-faster-than/</link>
                <guid>https://davidkoloski.me/blog/rkyv-is-faster-than/</guid>
                <description>&lt;p&gt;I&#x27;ve been working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;djkoloski&#x2F;rkyv&quot;&gt;rkyv&lt;&#x2F;a&gt;, a zero-copy deserialization library, since November of 2020. rkyv is similar to &lt;a href=&quot;https:&#x2F;&#x2F;capnproto.org&#x2F;&quot;&gt;Cap&#x27;n Proto&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;google.github.io&#x2F;flatbuffers&quot;&gt;FlatBuffers&lt;&#x2F;a&gt;, but has a handful of different design choices that make it stand out:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;No type restrictions: you can serialize anything with rkyv&lt;&#x2F;li&gt;
&lt;li&gt;No external schemas: you can use the library with just &lt;code&gt;#[derive]&lt;&#x2F;code&gt;s&lt;&#x2F;li&gt;
&lt;li&gt;Rust-only: it doesn&#x27;t sacrifice simplicity and performance for cross-language compatibility&lt;&#x2F;li&gt;
&lt;li&gt;Safe mutation: the only rust library (I tested) that supports mutating data without deserializing&lt;&#x2F;li&gt;
&lt;li&gt;Scalable: works equally well for small and large payloads&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;But just having design goals isn&#x27;t good enough, you need results to back them up. With that in mind, I can&#x27;t disclaim enough that I am the creator and maintainer of rkyv. However, the last thing I want is to be biased, so I made some benchmarks to hopefully convince you on their own merits.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;&#x2F;h2&gt;
&lt;p&gt;There are a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erickt&#x2F;rust-serialization-benchmarks&quot;&gt;couple&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;blog.logrocket.com&#x2F;rust-serialization-whats-ready-for-production-today&#x2F;&quot;&gt;different&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;only-cliches&#x2F;noproto#benchmarks&quot;&gt;benchmarks&lt;&#x2F;a&gt; already available, but in general they fail in a couple different ways:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;they-test-with-too-little-data&quot;&gt;They test with too little data&lt;&#x2F;h3&gt;
&lt;p&gt;This leads to highly variable results and can make it difficult to see whether one library is really faster than another&lt;&#x2F;p&gt;
&lt;h3 id=&quot;they-test-only-with-simple-data&quot;&gt;They test only with simple data&lt;&#x2F;h3&gt;
&lt;p&gt;The library may perform completely differently with complex and highly structured data&lt;&#x2F;p&gt;
&lt;h3 id=&quot;they-test-only-serialization-and-deserialization&quot;&gt;They test only serialization and deserialization&lt;&#x2F;h3&gt;
&lt;p&gt;For most serialization formats, all you can do is serialize and deserialize data. But zero-copy deserialization libraries can access and traverse data without deserializing it first. Knowing how these operations compare with each other is essential to evaluating their relative performance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-serialization-benchmark&quot;&gt;&lt;code&gt;rust_serialization_benchmark&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With these shortcomings in mind, I set off to make my own benchmarks. The goal was to be thorough and complete, and I think I did a pretty good job.&lt;&#x2F;p&gt;
&lt;p&gt;You can run the benchmarks yourself or look over the raw data &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;djkoloski&#x2F;rust_serialization_benchmark&quot;&gt;from the github repo&lt;&#x2F;a&gt;. I&#x27;ll summarize the results.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rules&quot;&gt;Rules&lt;&#x2F;h3&gt;
&lt;p&gt;Each library got tested on three different data sets:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;log&lt;&#x2F;code&gt;: a data set of HTTP request logs that are small and contain many strings&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;mesh&lt;&#x2F;code&gt;: a single mesh composed of triangles, each of which has three vertices and a normal&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;minecraft_savedata&lt;&#x2F;code&gt;: a highly-structured data set modeled after Minecraft player savedata&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Each data set is randomly generated from an RNG seeded with the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Nothing-up-my-sleeve_number&quot;&gt;first 20 digits of pi&lt;&#x2F;a&gt;, so the data tested is identical for every run. For each data set, a library was measured for the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Serialize&lt;&#x2F;strong&gt;: how long it took to serialize the data&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Deserialize&lt;&#x2F;strong&gt;: how long it took to deserialize the data&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Size&lt;&#x2F;strong&gt;: how many bytes the serialized data occupied&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Zlib&lt;&#x2F;strong&gt;: the serialized size after zlib compression&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Additionally, zero-copy deserialization libraries were tested for:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Access&lt;&#x2F;strong&gt;: how long it took to get access to the serialized data&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Read&lt;&#x2F;strong&gt;: how long it took to run through the data and read fields&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Update&lt;&#x2F;strong&gt;: how long it took to update the serialized data&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There are a couple footnotes that need explaining:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Abomonation requires a mutable backing to access and read serialized data. This means that it&#x27;s not viable for some use cases.&lt;&#x2F;li&gt;
&lt;li&gt;Abomonation does not support buffer mutation, so this wasn&#x27;t tested.&lt;&#x2F;li&gt;
&lt;li&gt;While Flatbuffers and Cap&#x27;n Proto support buffer mutation in the main (usually C++) libraries, the rust counterparts do not and they couldn&#x27;t be tested for this.&lt;&#x2F;li&gt;
&lt;li&gt;None of the other zero-copy deserialization frameworks provided deserialization capabilities by default. Writing and benchmarking my own deserialization code is somewhat meaningless for these. You can get an idea of what sort of deserialization performance you&#x27;d get by looking at the read benchmark.&lt;&#x2F;li&gt;
&lt;li&gt;Abomonation&#x27;s &lt;code&gt;decode&lt;&#x2F;code&gt; qualified as access not deserialize because it yields an immutable reference instead of a mutable object. In order to deserialize this object, a simple &lt;code&gt;Clone&lt;&#x2F;code&gt; would suffice but I&#x27;m not here to write and benchmark my own deserialization code.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;results&quot;&gt;Results&lt;&#x2F;h2&gt;
&lt;p&gt;These results are directly from the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;djkoloski&#x2F;rust_serialization_benchmark&quot;&gt;benchmark repo&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;log&quot;&gt;&lt;code&gt;log&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;This data set is composed of HTTP request logs that are small and contain many strings.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;raw-data&quot;&gt;Raw data&lt;&#x2F;h4&gt;
&lt;p&gt;For operations, time per iteration; for size, bytes. Lower is better.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; Format &#x2F; Lib &lt;&#x2F;th&gt;&lt;th&gt; Serialize &lt;&#x2F;th&gt;&lt;th&gt; Access &lt;&#x2F;th&gt;&lt;th&gt; Read &lt;&#x2F;th&gt;&lt;th&gt; Update &lt;&#x2F;th&gt;&lt;th&gt; Deserialize &lt;&#x2F;th&gt;&lt;th&gt; Size &lt;&#x2F;th&gt;&lt;th&gt; Size (zlib) &lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt; abomonation &lt;&#x2F;td&gt;&lt;td&gt; 315.13 us &lt;&#x2F;td&gt;&lt;td&gt; 36.773 us* &lt;&#x2F;td&gt;&lt;td&gt; 58.999 us* &lt;&#x2F;td&gt;&lt;td&gt; † &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 1705800 &lt;&#x2F;td&gt;&lt;td&gt; 507971 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; bincode &lt;&#x2F;td&gt;&lt;td&gt; 640.51 us &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 4.2787 ms &lt;&#x2F;td&gt;&lt;td&gt; 1045784 &lt;&#x2F;td&gt;&lt;td&gt; 374305 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; capnp &lt;&#x2F;td&gt;&lt;td&gt; 1.8558 ms &lt;&#x2F;td&gt;&lt;td&gt; 259.95 ns &lt;&#x2F;td&gt;&lt;td&gt; 711.84 us &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 1843240 &lt;&#x2F;td&gt;&lt;td&gt; 537966 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; cbor &lt;&#x2F;td&gt;&lt;td&gt; 1.9698 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 8.9702 ms &lt;&#x2F;td&gt;&lt;td&gt; 1407835 &lt;&#x2F;td&gt;&lt;td&gt; 407372 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; flatbuffers &lt;&#x2F;td&gt;&lt;td&gt; 2.6780 ms &lt;&#x2F;td&gt;&lt;td&gt; 2.9815 ns &lt;&#x2F;td&gt;&lt;td&gt; 162.95 us &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 1276368 &lt;&#x2F;td&gt;&lt;td&gt; 469962 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; postcard &lt;&#x2F;td&gt;&lt;td&gt; 714.70 us &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 4.4387 ms &lt;&#x2F;td&gt;&lt;td&gt; 765778 &lt;&#x2F;td&gt;&lt;td&gt; 312739 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; prost &lt;&#x2F;td&gt;&lt;td&gt; 5.4927 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 5.1024 ms &lt;&#x2F;td&gt;&lt;td&gt; 764951 &lt;&#x2F;td&gt;&lt;td&gt; 269811 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; rkyv &lt;&#x2F;td&gt;&lt;td&gt; 422.92 us &lt;&#x2F;td&gt;&lt;td&gt; 1.3616 ns &lt;&#x2F;td&gt;&lt;td&gt; 18.962 us &lt;&#x2F;td&gt;&lt;td&gt; 71.321 us &lt;&#x2F;td&gt;&lt;td&gt; 3.2492 ms &lt;&#x2F;td&gt;&lt;td&gt; 1065784 &lt;&#x2F;td&gt;&lt;td&gt; 333895 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; serde_json &lt;&#x2F;td&gt;&lt;td&gt; 4.4054 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 10.148 ms &lt;&#x2F;td&gt;&lt;td&gt; 1827461 &lt;&#x2F;td&gt;&lt;td&gt; 474358 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h4 id=&quot;comparison&quot;&gt;Comparison&lt;&#x2F;h4&gt;
&lt;p&gt;Relative to best. Higher is better.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; Format &#x2F; Lib &lt;&#x2F;th&gt;&lt;th&gt; Serialize &lt;&#x2F;th&gt;&lt;th&gt; Access &lt;&#x2F;th&gt;&lt;th&gt; Read &lt;&#x2F;th&gt;&lt;th&gt; Update &lt;&#x2F;th&gt;&lt;th&gt; Deserialize &lt;&#x2F;th&gt;&lt;th&gt; Size &lt;&#x2F;th&gt;&lt;th&gt; Size (zlib) &lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt; abomonation &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 0.00%* &lt;&#x2F;td&gt;&lt;td&gt; 32.14%* &lt;&#x2F;td&gt;&lt;td&gt; † &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 44.84% &lt;&#x2F;td&gt;&lt;td&gt; 53.12% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; bincode &lt;&#x2F;td&gt;&lt;td&gt; 49.20% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 75.94% &lt;&#x2F;td&gt;&lt;td&gt; 73.15% &lt;&#x2F;td&gt;&lt;td&gt; 72.08% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; capnp &lt;&#x2F;td&gt;&lt;td&gt; 16.98% &lt;&#x2F;td&gt;&lt;td&gt; 0.52% &lt;&#x2F;td&gt;&lt;td&gt; 2.66% &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 41.50% &lt;&#x2F;td&gt;&lt;td&gt; 50.15% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; cbor &lt;&#x2F;td&gt;&lt;td&gt; 16.00% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 36.22% &lt;&#x2F;td&gt;&lt;td&gt; 54.34% &lt;&#x2F;td&gt;&lt;td&gt; 66.23% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; flatbuffers &lt;&#x2F;td&gt;&lt;td&gt; 11.77% &lt;&#x2F;td&gt;&lt;td&gt; 45.67% &lt;&#x2F;td&gt;&lt;td&gt; 11.64% &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 59.93% &lt;&#x2F;td&gt;&lt;td&gt; 57.41% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; postcard &lt;&#x2F;td&gt;&lt;td&gt; 44.09% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 73.20% &lt;&#x2F;td&gt;&lt;td&gt; 99.89% &lt;&#x2F;td&gt;&lt;td&gt; 86.27% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; prost &lt;&#x2F;td&gt;&lt;td&gt; 5.74% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 63.68% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; rkyv &lt;&#x2F;td&gt;&lt;td&gt; 74.51% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 71.77% &lt;&#x2F;td&gt;&lt;td&gt; 80.81% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; serde_json &lt;&#x2F;td&gt;&lt;td&gt; 7.15% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 32.02% &lt;&#x2F;td&gt;&lt;td&gt; 41.86% &lt;&#x2F;td&gt;&lt;td&gt; 56.88% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;mesh&quot;&gt;&lt;code&gt;mesh&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The data set is a single mesh. The mesh contains an array of triangles, each of which has three
vertices and a normal vector.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;raw-data-1&quot;&gt;Raw data&lt;&#x2F;h4&gt;
&lt;p&gt;For operations, time per iteration; for size, bytes. Lower is better.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; Format &#x2F; Lib &lt;&#x2F;th&gt;&lt;th&gt; Serialize &lt;&#x2F;th&gt;&lt;th&gt; Access &lt;&#x2F;th&gt;&lt;th&gt; Read &lt;&#x2F;th&gt;&lt;th&gt; Update &lt;&#x2F;th&gt;&lt;th&gt; Deserialize &lt;&#x2F;th&gt;&lt;th&gt; Size &lt;&#x2F;th&gt;&lt;th&gt; Size (zlib) &lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt; abomonation &lt;&#x2F;td&gt;&lt;td&gt; 430.61 us &lt;&#x2F;td&gt;&lt;td&gt; 2.4135 ns* &lt;&#x2F;td&gt;&lt;td&gt; 177.87 us* &lt;&#x2F;td&gt;&lt;td&gt; † &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 6000024 &lt;&#x2F;td&gt;&lt;td&gt; 5380836 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; bincode &lt;&#x2F;td&gt;&lt;td&gt; 7.0288 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 12.294 ms &lt;&#x2F;td&gt;&lt;td&gt; 6000008 &lt;&#x2F;td&gt;&lt;td&gt; 5380823 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; capnp &lt;&#x2F;td&gt;&lt;td&gt; 15.854 ms &lt;&#x2F;td&gt;&lt;td&gt; 247.35 ns &lt;&#x2F;td&gt;&lt;td&gt; 8.9442 ms &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 16000056 &lt;&#x2F;td&gt;&lt;td&gt; 6780527 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; cbor &lt;&#x2F;td&gt;&lt;td&gt; 43.109 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 70.247 ms &lt;&#x2F;td&gt;&lt;td&gt; 13122324 &lt;&#x2F;td&gt;&lt;td&gt; 7527423 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; flatbuffers &lt;&#x2F;td&gt;&lt;td&gt; 1.9518 ms &lt;&#x2F;td&gt;&lt;td&gt; 2.9588 ns &lt;&#x2F;td&gt;&lt;td&gt; 152.39 us &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 6000024 &lt;&#x2F;td&gt;&lt;td&gt; 5380800 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; postcard &lt;&#x2F;td&gt;&lt;td&gt; 6.6844 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 8.9408 ms &lt;&#x2F;td&gt;&lt;td&gt; 6000003 &lt;&#x2F;td&gt;&lt;td&gt; 5380817 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; prost &lt;&#x2F;td&gt;&lt;td&gt; 34.037 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 20.232 ms &lt;&#x2F;td&gt;&lt;td&gt; 8750000 &lt;&#x2F;td&gt;&lt;td&gt; 6683814 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; rkyv &lt;&#x2F;td&gt;&lt;td&gt; 1.1217 ms &lt;&#x2F;td&gt;&lt;td&gt; 1.4006 ns &lt;&#x2F;td&gt;&lt;td&gt; 172.20 us &lt;&#x2F;td&gt;&lt;td&gt; 649.18 us &lt;&#x2F;td&gt;&lt;td&gt; 1.9594 ms &lt;&#x2F;td&gt;&lt;td&gt; 6000008 &lt;&#x2F;td&gt;&lt;td&gt; 4263104 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; serde_json &lt;&#x2F;td&gt;&lt;td&gt; 105.86 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 83.016 ms &lt;&#x2F;td&gt;&lt;td&gt; 26192883 &lt;&#x2F;td&gt;&lt;td&gt; 9612105 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h4 id=&quot;comparison-1&quot;&gt;Comparison&lt;&#x2F;h4&gt;
&lt;p&gt;Relative to best. Higher is better.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; Format &#x2F; Lib &lt;&#x2F;th&gt;&lt;th&gt; Serialize &lt;&#x2F;th&gt;&lt;th&gt; Access &lt;&#x2F;th&gt;&lt;th&gt; Read &lt;&#x2F;th&gt;&lt;th&gt; Update &lt;&#x2F;th&gt;&lt;th&gt; Deserialize &lt;&#x2F;th&gt;&lt;th&gt; Size &lt;&#x2F;th&gt;&lt;th&gt; Size (zlib) &lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt; abomonation &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 58.03%* &lt;&#x2F;td&gt;&lt;td&gt; 85.67%* &lt;&#x2F;td&gt;&lt;td&gt; † &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 79.23% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; bincode &lt;&#x2F;td&gt;&lt;td&gt; 6.13% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 15.94% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 79.23% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; capnp &lt;&#x2F;td&gt;&lt;td&gt; 2.72% &lt;&#x2F;td&gt;&lt;td&gt; 0.57% &lt;&#x2F;td&gt;&lt;td&gt; 1.70% &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 37.50% &lt;&#x2F;td&gt;&lt;td&gt; 62.87% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; cbor &lt;&#x2F;td&gt;&lt;td&gt; 1.00% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 2.79% &lt;&#x2F;td&gt;&lt;td&gt; 45.72% &lt;&#x2F;td&gt;&lt;td&gt; 56.63% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; flatbuffers &lt;&#x2F;td&gt;&lt;td&gt; 22.06% &lt;&#x2F;td&gt;&lt;td&gt; 47.34% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 79.23% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; postcard &lt;&#x2F;td&gt;&lt;td&gt; 6.44% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 21.92% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 79.23% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; prost &lt;&#x2F;td&gt;&lt;td&gt; 1.27% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 9.68% &lt;&#x2F;td&gt;&lt;td&gt; 68.57% &lt;&#x2F;td&gt;&lt;td&gt; 63.78% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; rkyv &lt;&#x2F;td&gt;&lt;td&gt; 38.39% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 88.50% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; serde_json &lt;&#x2F;td&gt;&lt;td&gt; 0.41% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 2.36% &lt;&#x2F;td&gt;&lt;td&gt; 22.91% &lt;&#x2F;td&gt;&lt;td&gt; 44.35% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;minecraft-savedata&quot;&gt;&lt;code&gt;minecraft_savedata&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The data set is composed of Minecraft player saves that contain highly-structured data.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;raw-data-2&quot;&gt;Raw data&lt;&#x2F;h4&gt;
&lt;p&gt;For operations, time per iteration; for size, bytes. Lower is better.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; Format &#x2F; Lib &lt;&#x2F;th&gt;&lt;th&gt; Serialize &lt;&#x2F;th&gt;&lt;th&gt; Access &lt;&#x2F;th&gt;&lt;th&gt; Read &lt;&#x2F;th&gt;&lt;th&gt; Update &lt;&#x2F;th&gt;&lt;th&gt; Deserialize &lt;&#x2F;th&gt;&lt;th&gt; Size &lt;&#x2F;th&gt;&lt;th&gt; Size (zlib) &lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt; abomonation &lt;&#x2F;td&gt;&lt;td&gt; 368.23 us &lt;&#x2F;td&gt;&lt;td&gt; 40.823 us* &lt;&#x2F;td&gt;&lt;td&gt; 41.413 us* &lt;&#x2F;td&gt;&lt;td&gt; † &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 1290592 &lt;&#x2F;td&gt;&lt;td&gt; 393696 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; bincode &lt;&#x2F;td&gt;&lt;td&gt; 806.73 us &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 3.4132 ms &lt;&#x2F;td&gt;&lt;td&gt; 569975 &lt;&#x2F;td&gt;&lt;td&gt; 240897 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; capnp &lt;&#x2F;td&gt;&lt;td&gt; 863.41 us &lt;&#x2F;td&gt;&lt;td&gt; 256.55 ns &lt;&#x2F;td&gt;&lt;td&gt; 5.3431 us &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 835784 &lt;&#x2F;td&gt;&lt;td&gt; 342099 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; cbor &lt;&#x2F;td&gt;&lt;td&gt; 2.4356 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 8.8797 ms &lt;&#x2F;td&gt;&lt;td&gt; 1109821 &lt;&#x2F;td&gt;&lt;td&gt; 347562 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; flatbuffers &lt;&#x2F;td&gt;&lt;td&gt; 38.683 ms &lt;&#x2F;td&gt;&lt;td&gt; 2.9212 ns &lt;&#x2F;td&gt;&lt;td&gt; 3.9676 us &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 849472 &lt;&#x2F;td&gt;&lt;td&gt; 349208 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; postcard &lt;&#x2F;td&gt;&lt;td&gt; 774.37 us &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 3.7533 ms &lt;&#x2F;td&gt;&lt;td&gt; 356311 &lt;&#x2F;td&gt;&lt;td&gt; 213270 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; prost &lt;&#x2F;td&gt;&lt;td&gt; 5.8678 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 5.4083 ms &lt;&#x2F;td&gt;&lt;td&gt; 596811 &lt;&#x2F;td&gt;&lt;td&gt; 306728 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; rkyv &lt;&#x2F;td&gt;&lt;td&gt; 843.80 us &lt;&#x2F;td&gt;&lt;td&gt; 1.3837 ns &lt;&#x2F;td&gt;&lt;td&gt; 282.88 ns &lt;&#x2F;td&gt;&lt;td&gt; 6.5422 us &lt;&#x2F;td&gt;&lt;td&gt; 2.4810 ms &lt;&#x2F;td&gt;&lt;td&gt; 725176 &lt;&#x2F;td&gt;&lt;td&gt; 334238 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; serde_json &lt;&#x2F;td&gt;&lt;td&gt; 4.3501 ms &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 10.699 ms &lt;&#x2F;td&gt;&lt;td&gt; 1623197 &lt;&#x2F;td&gt;&lt;td&gt; 472162 &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h4 id=&quot;comparison-2&quot;&gt;Comparison&lt;&#x2F;h4&gt;
&lt;p&gt;Relative to best. Higher is better.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; Format &#x2F; Lib &lt;&#x2F;th&gt;&lt;th&gt; Serialize &lt;&#x2F;th&gt;&lt;th&gt; Access &lt;&#x2F;th&gt;&lt;th&gt; Read &lt;&#x2F;th&gt;&lt;th&gt; Update &lt;&#x2F;th&gt;&lt;th&gt; Deserialize &lt;&#x2F;th&gt;&lt;th&gt; Size &lt;&#x2F;th&gt;&lt;th&gt; Size (zlib) &lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt; abomonation &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 0.00%* &lt;&#x2F;td&gt;&lt;td&gt; 0.68%* &lt;&#x2F;td&gt;&lt;td&gt; † &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 27.61% &lt;&#x2F;td&gt;&lt;td&gt; 54.17% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; bincode &lt;&#x2F;td&gt;&lt;td&gt; 45.64% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 72.69% &lt;&#x2F;td&gt;&lt;td&gt; 62.51% &lt;&#x2F;td&gt;&lt;td&gt; 88.53% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; capnp &lt;&#x2F;td&gt;&lt;td&gt; 42.65% &lt;&#x2F;td&gt;&lt;td&gt; 0.54% &lt;&#x2F;td&gt;&lt;td&gt; 5.29% &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 42.63% &lt;&#x2F;td&gt;&lt;td&gt; 62.34% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; cbor &lt;&#x2F;td&gt;&lt;td&gt; 15.12% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 27.94% &lt;&#x2F;td&gt;&lt;td&gt; 32.11% &lt;&#x2F;td&gt;&lt;td&gt; 61.36% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; flatbuffers &lt;&#x2F;td&gt;&lt;td&gt; 0.95% &lt;&#x2F;td&gt;&lt;td&gt; 47.37% &lt;&#x2F;td&gt;&lt;td&gt; 7.13% &lt;&#x2F;td&gt;&lt;td&gt; § &lt;&#x2F;td&gt;&lt;td&gt; ‡ &lt;&#x2F;td&gt;&lt;td&gt; 41.94% &lt;&#x2F;td&gt;&lt;td&gt; 61.07% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; postcard &lt;&#x2F;td&gt;&lt;td&gt; 47.55% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 66.10% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; prost &lt;&#x2F;td&gt;&lt;td&gt; 6.28% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 45.87% &lt;&#x2F;td&gt;&lt;td&gt; 59.70% &lt;&#x2F;td&gt;&lt;td&gt; 69.53% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; rkyv &lt;&#x2F;td&gt;&lt;td&gt; 43.64% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 100.00% &lt;&#x2F;td&gt;&lt;td&gt; 49.13% &lt;&#x2F;td&gt;&lt;td&gt; 63.81% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt; serde_json &lt;&#x2F;td&gt;&lt;td&gt; 8.46% &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt;  &lt;&#x2F;td&gt;&lt;td&gt; 23.19% &lt;&#x2F;td&gt;&lt;td&gt; 21.95% &lt;&#x2F;td&gt;&lt;td&gt; 45.17% &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;footnotes&quot;&gt;Footnotes:&lt;&#x2F;h3&gt;
&lt;p&gt;* &lt;em&gt;abomonation requires a mutable backing to access data&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;† &lt;em&gt;abomonation does not support buffer mutation&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;‡ &lt;em&gt;do not provide deserialization capabilities, but the user can write their own&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;§ &lt;em&gt;supports buffer mutation, but not in the rust implementation&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;analysis&quot;&gt;Analysis&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;cbor-serde-json&quot;&gt;CBOR &#x2F; serde_json&lt;&#x2F;h3&gt;
&lt;p&gt;Unsurprisingly, these two had very similar performance because they&#x27;re almost the same format. CBOR did a bit better than serde_json in every benchmark, but these two consistently trailed behind all the other frameworks (in some cases, very considerably behind).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;prost&quot;&gt;Prost&lt;&#x2F;h3&gt;
&lt;p&gt;Prost was the chosen representative for protobuf-style serialization. Its performance was average-to-lackluster on every benchmark, with the exception of the log size benchmark. It beat out postcard, which consistently performed extremely well in the size&#x2F;zlib categories. This shows just how much the format was optimized for stringy data and minimizing wire size.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bincode-postcard&quot;&gt;bincode &#x2F; postcard&lt;&#x2F;h3&gt;
&lt;p&gt;Despite being completely different libraries, bincode and postcard had very similar benchmark results. Serialize and deserialize speed were very close for both of them, and the main difference between the two was usually the final size. Postcard consistently beat bincode on size and zlib. I suspect that they are using very similar techniques, but that postcard has a few more tricks up its sleeve that don&#x27;t cost much to perform but give it a sizeable advantage.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cap-n-proto&quot;&gt;Cap&#x27;n Proto&lt;&#x2F;h3&gt;
&lt;p&gt;Cap&#x27;n Proto had a good showing, and it proved its worth as a replacement for protobuf. Compared to prost, it was faster to serialize, and supported comparatively fast zero-copy deserialization. These two features are absolutely killer. Unfortunately, it didn&#x27;t stack up nearly as well against the other zero-copy frameworks. It consistently had disapointing access and read times compared to its competitors, and failed pretty miserably on the mesh size benchmarks. This makes sense as it wasn&#x27;t built to handle large amounts of raw data, but it was disappointing to see so much wasted space compared to FlatBuffers.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;flatbuffers&quot;&gt;FlatBuffers&lt;&#x2F;h3&gt;
&lt;p&gt;FlatBuffers is the comparison point for zero-copy deserialization. It&#x27;s got a lot of usage, was built specifically for performance, and proves out the zero-copy concept. It did well in all categories on most of the tests, but had a major stumbling block. In the &lt;code&gt;minecraft_savedata&lt;&#x2F;code&gt; test, its serialization performance was by far the worst, even worse than serde_json (which had to write twice as much data!). This highlights a major weakness of FlatBuffers: its very poor serialization performance on highly-structured data. It&#x27;s possible (even probable) that I wrote this bench more poorly than it could be, but it&#x27;s enough that I wouldn&#x27;t recommend its use for general-purpose data.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;abomonation&quot;&gt;Abomonation&lt;&#x2F;h3&gt;
&lt;p&gt;Abomonation was definitely a bright spot in the benchmarks. It proved out its insanely fast serialization on every bench, and didn&#x27;t suffer from some of the size traps that its competitors fell into. It would be an easy library to recommend if it didn&#x27;t come with so many caveats. It&#x27;s very unsafe, non-portable, requires mutable backing to access its data, and doesn&#x27;t support mutations. Nonetheless, abomonation was a really impressive contender in every benchmark.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rkyv&quot;&gt;rkyv&lt;&#x2F;h3&gt;
&lt;p&gt;I went into these benchmarks not knowing how rkyv would perform relative to its peers, but confident that it would make a good showing. It ended up doing much better than I expected. It won nearly every performance category, and was highly competitive with the winner when it didn&#x27;t. It also did so without compromising on size, where it was also highly competitive. Finally it showed exceptional scalability, peforming equally well on all different kinds of data where its zero-copy competitors all hard shortcomings on one or more of the data sets. Unlike abomonation, it&#x27;s also a safe, highly-portable format that doesn&#x27;t need mutable backing and has more feature support than other competitors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;I welcome and encourage anyone to run &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;djkoloski&#x2F;rust_serialization_benchmark&quot;&gt;the benchmarks&lt;&#x2F;a&gt; for themselves and open pull requests to improve or clean up whatever they want. I am confident in the validity of these results, and will happily update the tables as changes are made. I will update my analyses if there are any major changes.&lt;&#x2F;p&gt;
&lt;p&gt;My hope is that this article not only convinced you that &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;djkoloski&#x2F;rkyv&quot;&gt;rkyv&lt;&#x2F;a&gt; is one of the best-performing serializers available, but that it also helped you understand the relationships between the different serialization solutions available in rust today.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;If you&#x27;re interested in rkyv, I encourage you to contribute to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;djkoloski&#x2F;rkyv&#x2F;issues&#x2F;67&quot;&gt;request for feedback&lt;&#x2F;a&gt; for planning its future&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Thanks to &lt;a href=&quot;https:&#x2F;&#x2F;blog.burntsushi.net&#x2F;ripgrep&#x2F;&quot;&gt;burntsushi&lt;&#x2F;a&gt; for the article title inspiration&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>rkyv architecture and internals</title>
                <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
                <link>https://davidkoloski.me/blog/rkyv-architecture/</link>
                <guid>https://davidkoloski.me/blog/rkyv-architecture/</guid>
                <description>&lt;h1 id=&quot;what-is-rkyv&quot;&gt;What is rkyv?&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;djkoloski&#x2F;rkyv&quot;&gt;rkyv&lt;&#x2F;a&gt; is a zero-copy deserialization framework written in rust. It&#x27;s deeply integrated into the language and has a lot of neat features with the new v0.2.0 release.&lt;&#x2F;p&gt;
&lt;p&gt;I originally released and &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;jss6h4&#x2F;rkyv_a_zerocopy_deserialization_framework_for_rust&#x2F;&quot;&gt;posted about rkyv&lt;&#x2F;a&gt; in the rust subreddit and got a lot of great feedback. Along with a couple highly desired features, many people asked for a blog post about the design and internals of rkyv. This blog post should serve as a jumping-off point to understand rkyv and zero-copy deserialization in general.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zero-copy-deserialization&quot;&gt;Zero-copy deserialization&lt;&#x2F;h1&gt;
&lt;p&gt;Zero-copy deserialization is a technique used to reduce memory consumption and eliminate work when reading from disk or another external source. This isn&#x27;t really a precise term, since &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;serde-rs&#x2F;serde&#x2F;releases&#x2F;tag&#x2F;v1.0.0&quot;&gt;serde has support&lt;&#x2F;a&gt; for zero-copy deserialization, but a very different kind than rkyv. Zero-copy deserialization is more of an umbrella term for techniques that use some of the data from the source and therefore don&#x27;t copy it when deserializing, hence the name.&lt;&#x2F;p&gt;
&lt;p&gt;To be more precise, rkyv implements total zero-copy deserialization. All of the output of deserialization is borrowed from the input and no work is required to transform it from the external (on-disk) representation to the in-memory one. In practice, this means that you can do things like &lt;code&gt;mmap&lt;&#x2F;code&gt; files into memory and use them without deserialization. This is a technique that is sometimes used in the game industry, where performance requirements are very strict. Total zero-copy deserialization can drastically reduce load times which translates directly into a better user experience.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;rkyv-architecture&quot;&gt;rkyv architecture&lt;&#x2F;h1&gt;
&lt;p&gt;This is where we can start getting into the meat and potatoes of rkyv. The first thing to understand about rkyv is relative pointers.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;relative-pointers&quot;&gt;Relative pointers&lt;&#x2F;h2&gt;
&lt;p&gt;The first hurdle for total zero-copy deserialization is that regular pointers are not serializable. A pointer is just some address in memory, and that means that it might not even be a valid location for your program on a subsequent run. Even if we could get all of our data back into memory, we would still have to fix up the pointers so they point to the right locations.&lt;&#x2F;p&gt;
&lt;p&gt;Relative pointers are a technique where instead of writing an absolute pointer to disk (which wouldn&#x27;t come back pointing to the right place), we instead write an &lt;em&gt;offset&lt;&#x2F;em&gt; to some memory. That offset essentially points to &amp;quot;the address of this plus some bytes&amp;quot;. A simple example of a relative pointer to a string is these bytes:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#323232;&quot;&gt;0x0000    04 00 00 00 68 65 6c 6c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;0x0008    6f 20 77 6f 72 6c 64 21&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ll assume that our relative pointers use 32-bit offsets. The first four bytes of the archive are the relative pointer, which encodes the offset to the string. The first four bytes are &lt;code&gt;04 00 00 00&lt;&#x2F;code&gt;, which is four on little endian machines. This means that the data is located four bytes forward from the address of the offset. Since the offset is located at &lt;code&gt;0x0000&lt;&#x2F;code&gt;, we should look for the data at &lt;code&gt;0x0000 + 4 = 0x0004&lt;&#x2F;code&gt;!&lt;&#x2F;p&gt;
&lt;p&gt;Taking a peek at that location reveals some bytes that look like ASCII, but we don&#x27;t know how many yet! Along with the data for the bytes of a string, we also need to encode the length of the string. Let&#x27;s update our example:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#323232;&quot;&gt;0x0000    08 00 00 00 0c 00 00 00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;0x0008    68 65 6c 6c 6f 20 77 6f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;0x0010    72 6c 64 21 cd cd cd cd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now there&#x27;s two four-byte values: first the relative pointer and second the string length. The relative pointer now has bytes &lt;code&gt;08 00 00 00&lt;&#x2F;code&gt;, four more than before since we now need to skip over the string length bytes. So the data is now located at &lt;code&gt;0x0000 + 8 = 0x0008&lt;&#x2F;code&gt;. The length bytes tell us there should be 12 bytes at that location. Reading off the first 12 bytes from there gives us &lt;code&gt;&amp;quot;hello world!&amp;quot;&lt;&#x2F;code&gt;! Success!&lt;&#x2F;p&gt;
&lt;p&gt;In order to map those bytes into a structure in memory, we might put our &lt;code&gt;ArchivedString&lt;&#x2F;code&gt; together like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;ArchivedString {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;len: &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;ArchivedString {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#795da3;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;] {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; ptr &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(self &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;as *const Self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;.cast::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;&amp;gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(self.ptr);&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;slice::from_raw_parts(ptr, self.len &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#795da3;&quot;&gt;as_str&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;str &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;::from_utf8_unchecked(self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;())&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reality is just a little bit more complicated than this, but this is pretty close to the same code you can find in rkyv right now. The general idea behind rkyv is to take build these structures for all of our types so that we can serialize them out and get them back later without having to deserialize.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;archiving-dependencies&quot;&gt;Archiving dependencies&lt;&#x2F;h2&gt;
&lt;p&gt;The next problem we have to tackle is actually creating those relative pointers. In order to make one, we need to know the locations of &lt;em&gt;both&lt;&#x2F;em&gt; the target memory and the relative pointer itself. This is a problem; how can we know where the relative pointer should point if we haven&#x27;t written it yet?&lt;&#x2F;p&gt;
&lt;p&gt;Imagine that we had some struct that had two strings in it:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;Pair {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;key: String,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;value: String,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s archived version would look like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;ArchivedPair {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;key: ArchivedString,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;value: ArchivedString,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In order to make our archived pair, we have to write the bytes of the key and value first, then construct the relative pointers for the strings. Let&#x27;s brainstorm roughly what that would look like:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;Pair {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#795da3;&quot;&gt;archive&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;self, writer: &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; Write) -&amp;gt; ArchivedPair {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; key_pos &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; writer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(self.key.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;());&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; value_pos &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; writer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(self.value.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;());&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; base &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; writer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;pos&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;();&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; key_off &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;offset_of!(ArchivedPair, key);&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; value_off &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;offset_of!(ArchivedPair, value);&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;ArchivedPair {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;key: ArchivedString::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;base &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; key_off,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;key_pos,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;self.key.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;),&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;value: ArchivedString::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;base &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; value_off,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;value_pos,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;self.value.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;),&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Right off the bat, we&#x27;ve introduced some new concepts:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;offset_of!&lt;&#x2F;code&gt; is a macro that tells us the offset of a field in our struct. We need to use this to make sure that we&#x27;re using the positions of the strings &lt;em&gt;within&lt;&#x2F;em&gt; our struct instead of the position of the start of the struct.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Write&lt;&#x2F;code&gt; is a writer like &lt;code&gt;std::io::Write&lt;&#x2F;code&gt; that we can write bytes to and which also knows the current position. We need this to get the &lt;code&gt;base&lt;&#x2F;code&gt; for our relative pointers.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is a little simplified, but both of these are both concepts used extensively in rkyv. And this works! But what if we wanted to write an array of &lt;code&gt;ArchivedPair&lt;&#x2F;code&gt;s?&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve run into a problem!&lt;&#x2F;p&gt;
&lt;p&gt;We can write out the first pair just fine, but when write out the second pair we accidentally write our two strings where the second pair should be! Because they&#x27;re in an array, the archived pairs have to be right next to each other. But there has to be a way around this, this is exactly like how we had to write out the key and value before building our pair!&lt;&#x2F;p&gt;
&lt;p&gt;Taking a look at the archive function, you can see that the archive process is broken up into two steps:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Write out the bytes of your dependencies&lt;&#x2F;li&gt;
&lt;li&gt;Get the current position and figure out your relative pointers using it&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This translates to the two core traits in rkyv: &lt;code&gt;Archive&lt;&#x2F;code&gt; and &lt;code&gt;Resolve&lt;&#x2F;code&gt;. The first step is handled by &lt;code&gt;Archive&lt;&#x2F;code&gt; and the second is handled by &lt;code&gt;Resolve&lt;&#x2F;code&gt;. So what do these traits do?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;archive-and-resolve&quot;&gt;&lt;code&gt;Archive&lt;&#x2F;code&gt; and &lt;code&gt;Resolve&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;Archive&lt;&#x2F;code&gt; writes out the dependencies of the type and returns a &lt;em&gt;resolver&lt;&#x2F;em&gt;. A resolver is a struct that contains the extra information we need to make an archived version of our type from the writer position and original value. A string&#x27;s implementation might look like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;Archive &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;String {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;Resolver &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;= usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#795da3;&quot;&gt;archive&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;self, writer: &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; Writer) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;Resolver {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; pos &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; writer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;pos&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;();&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;writer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;as_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;());&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;pos&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;Resolve &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;String {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;Archived &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt; ArchivedString;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#795da3;&quot;&gt;resolve&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;self,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;pos: &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;resolver: &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#a71d5d;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;Archived {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;ArchivedString {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;ptr: RelPtr::from_to(pos, resolver),&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;len: self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#62a35c;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;(),&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#323232;&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the archive step, we write out the bytes for the string and return the position those bytes were written to. In the resolve step, we take that position and make a new relative pointer that points to them. Now if we wanted to archive an array of strings, we can archive them all and &lt;em&gt;then&lt;&#x2F;em&gt; resolve them all.&lt;&#x2F;p&gt;
&lt;p&gt;Once again, this is very simplified for the sake of example. But the real implementations of these are not too different!&lt;&#x2F;p&gt;
&lt;p&gt;rkyv provides archived versions of core and standard library types for you out of the box, but you still need to provide them for your own types. That&#x27;s why rkyv also provides a handy derive macro that does all the heavy lifting for you! Just add &lt;code&gt;#[derive(Archive)]&lt;&#x2F;code&gt; to your type and rkyv will generate an archived type, resolver, and implementations of &lt;code&gt;Archive&lt;&#x2F;code&gt; and &lt;code&gt;Resolve&lt;&#x2F;code&gt; automagically.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;extending-rkyv&quot;&gt;Extending rkyv&lt;&#x2F;h1&gt;
&lt;p&gt;Being able to archive types made out of library types is enough functionality for some, but there are a few holes in our system that we need to plug up.&lt;&#x2F;p&gt;
&lt;p&gt;The first trait is &lt;code&gt;ArchiveRef&lt;&#x2F;code&gt;, which is like &lt;code&gt;Archive&lt;&#x2F;code&gt; for unsized types. Instead of resolving to an archived version of themselves, they instead resolve to a something that dereferences to the archived type. A good way to think about this is that &lt;code&gt;ArchiveRef&lt;&#x2F;code&gt; is &lt;code&gt;Archive&lt;&#x2F;code&gt; for unsized types which use wide pointers with extra associated data.&lt;&#x2F;p&gt;
&lt;p&gt;This allows us to implement &lt;code&gt;Archive&lt;&#x2F;code&gt; for types like &lt;code&gt;Box&lt;&#x2F;code&gt;, which needs to be able to archive unsized types like slices and str&#x27;s. We can also archive our own unsized types with things like trailing slices, even though they&#x27;re pretty uncommon in practice.&lt;&#x2F;p&gt;
&lt;p&gt;The last hole we need to plug is trait objects. Unfortunately this one is pretty complicated, so if you&#x27;re really interested in how trait object archiving works, I would recommend you look at some of the source for &lt;code&gt;rkyv_dyn&lt;&#x2F;code&gt;, the crate that adds trait object serialization to rkyv.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;Even though this overview is pretty basic, it gives a relatively complete overview of how rkyv works internally. The core ideas are pretty simple, the complicated part is really just writing the core and std implementations.&lt;&#x2F;p&gt;
&lt;p&gt;If you weren&#x27;t interested in rkyv before and are now, try it out and see how you like it! I just shipped a shiny new version with some great new features including validation and mutable archives. You can find the source &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;djkoloski&#x2F;rkyv&quot;&gt;on github&lt;&#x2F;a&gt; for more information.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks for reading!&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
